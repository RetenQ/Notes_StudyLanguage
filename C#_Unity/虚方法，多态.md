### 设计原则——依赖倒置原则  
程序设计套依赖于抽象类，而不依赖于具体类  

### 基类派生类的引用 
可以引用基类来创建一个派生类的对象  
>派生类的对象包含基类部分和派生类部分  
>我们可以通过一个**基类类型**的引用指向派生类  
>通过这种方式的指向，**我们只能访问派生类中的基类部分**
```C#
Pet Dog = new Dog();
```

比如此时我调用了基类和派生类都有的一个方法Name()  
本来基类的Name()应该被隐藏而调用派生类新的Name()方法  
但是因为此时我们是利用了基类的引用而创建了该对象，所以我们只能访问基类的部分  
因此调用的还是基类的方法  

### 虚方法与多态  
虚方法：声明为**vitrual**的方法就是虚方法。基类的虚方法可以载派生类中使用**override**进行重写  

多态：通过指向派生类的**基类引用**，调用**虚函数**。根据引用所指向派生类的实际类型，调用派生类中的**同名重写函数**  

在利用虚方法和多态时，对于基类的引用时，如果你调用了一个方法  
会先判断一个方法是否是虚方法，如果是，则会查找对应的对象是否有override的方法  
如果有，则执行override方法，否则就执行基类的那个方法  

### 其它
重写虚方法必须有相同的可访问性，且基类方法不能是private  
不能重写**非虚方法** (这一点和一些语言不一样)  
不能重写static方法  
方法，属性，索引器，事件。都可以**声明为vitrual 或者override**  
