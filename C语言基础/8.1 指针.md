# 指针

### 导入
我们从sizeof谈起：它是一个运算符。给出某个类型或变量在内存中占据的位置，以字节大小表示（1字节=4比特）

接着是&，它实质上是一个运算符，它能够**获得变量的地址**（这也意味着它的操作数必须是变量）
顺带一提，用printf输出地址时，使用%p , 而且取出的地址大小是否和int相同取决于编译器（32位架构还是64位架构）
```c
int i = 0 ;
printf("%p" , & i) ; 

return 0 ;
```
   
&不能对没有地址的东西取地址，比如a++,++a,a+b,...  
  
### 指针
我们一直所说的“指针”，才是真正的，能够完美**存储地址**的变量
>指针就是保存地址的变量
我们使用星号* 表示我们所想要的这个变量，是一个指针 
星号是“加给”变量的，比如
int *p,q ; 这里面的p是指针，而q就是普通的整型  

##### 指针变量
变量的值是内存的地址
普通变量的值是实际的值
指针变量的值是**具有实际值的变量**的**地址**   
  
*是一个单目运算符，用来访问指针的值所表示的地址上的变量
它可以做右值，也可以做左值
```c
int k = *p ; 
*p = k+1 ;
```

由于指针变量的特殊性，我们若在函数中修改了指针变量，那么也会修改它所指向的值
```c
void f(int *p);
void g(int k);

int main(void){
    int i = 6 ; 
    printf("&i = %p\n",&i);
    f(&i);
    g(i);
    return 0 ;
}

void f (int *p){
    printf(" p = %p\n" , p);
    printf(" p = %p\n" , *p);
    *p = 26 ; //就在这里，把p变量的地址指向的那个变量（就是i）改为26
}

void g (int k){
    printf("k = %d \n " , k);
}

```
   
### 指针与数组
函数参数表中的数组，实质上就是个指针(这也是为什么写a[]和a[10]之类的是一样的)，也因此在函数中我们不能直接用sizeof得到正确的数组长度
>函数参数表中的数组实际上是指针，但是可以用数组的运算符[]来运算  
  
实际上，数组变量是特殊的指针
1.数组变量本身表达地址，所以我们取数组的地址时无需使用&
```c
int a[10] ; 
int *p = a ; 
```   
  
2.但是数组的单元表达的是变量，我们需要用&来取它。数组a的地址，等于数组单元a[0]的地址
3.*运算符可以对指针做，也可以对数组做
4.数组变量是const的指针，所以不能被赋值

