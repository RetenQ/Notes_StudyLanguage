# 位、换位运算
C是接近底层的一门语言，C使得我们可以使用一些接近底层的操作  
除此之外，在算法中，位运算也是不可小视的一部分

## 换位运算    

### 换位运算符
C语言有这些按位运算符   
```&```：按位的与   
```|```：按位的或   
```~```：按位的取反 
```^```：按位的异或 
```<<```：左移
```>>```：右移  
下文若无特殊表述，均是位运算    

#### 按位与
若x==1,y==1,(x&y) = 1 ; 否则(x&y) = 0   
常被用于两种应用:
1.让某一位或某些位为0，如: x & 0xFE  
> FE:1111 1110，它可以使得某一个数的最低位变成0  
2.取某一个数中的一段: x & 0xFF  
> FF:1111 1111,使和FE进行按位与的部分皆被保存     

#### 按位或
若x==1,或y==1，那么就有(x|y) = 1 , 否则才有(x|y) = 0    
常被用于两种应用:   
1.使得一位或者几个位为1，如：x | 0x01   
2.把两个数相拼接，如: 0X00FF | 0XFF00 ,结果就是0XFFFF   

#### 按位取反    
把1位变成0，0位变成1    
想要得到全部位为1的数，使用```~0``` 

#### 按位异或
在C中，没有表示幂次的运算符，```^```表示按位异或    
若x==y,那么有(x^y) = 0  
否则，(x^y) = 1
> 如果两个位相等，结果为0；不相等，结果为1  
> 对同一个变量，连续使用另一个相同的变量连续异或两次，则等于没做    
> 上述那一条可以做一个非常非常弱的加密运算↑

### 逻辑运算与按位运算  
在逻辑运算中，实质上它只看到两个只：0和1    
可以认为逻辑运算相当于把所有非0值都变成1，然后做按位运算    
5&4 ->4
5&&4 -> 1&1 ->1
>实际上，在计算机中，我们只有按位运算，而没有逻辑运算   

## 移位运算 

### 左移    
i << j 
把i中所有的为都向左移动j个位置，而右边填入0     
所有小于int的类型，移位使用int的方式来做，结果也是int   
$x <<= 1$ 等价于 $x *= 2 $  (<<=表示<<1 后的结果，类比x+=2这种形式)    
$x <<= n$ 等价于 $x *= 2^n$ 

### 右移
i >> j 
i中所有的位向右移j位    
所有小于int的类型，移位以int的方式来做，结果是int   
对于```unsigned```类型，左边填入0   
对于```signed```类型，左边填入原来的最高位(保持符号不变)    
> 也就是说，此时有符号和无符号是不一样的    
$x >>= 1$ 等价于 $x /= 2 $      
$x >>= n$ 等价于 $x /= 2^n$ 

另外，移位的位置不要使用负数，这是没有定义的行为    

## 位运算例子和位段   
> 该部分比较简略，若想了解请参考翁恺老师的13.2-3位运算例子和12.2-4位段    
> 或者，直接刷相关的题目，能更好地理解  

例子:输出一个数的二进制 
```C
#include <stido.h>
int main(int argc , char const *argv[]){
    int number ; 
    scanf("%d" , &number) ; 
    unsigned mask = lu<<31 ; 

    for( ; mask ; mask >>=1 ){
        printf("%d" ， number &mask?1:0);
    }
    printf("\n") ; 

    return 0 ;
}
```
我们可以把一个int的若干位都合成一个结构     
```C
struct {
    unsigned int leading : 3 ; 
    unsigned int FLAG1: 1 ;
    unsigned int FLAG2: 2 ;
    int trailing: 11 ;
};
``` 
每一个成员的后面，有一个```:```,其后面的数字表示一个成员占几个比特  

定义位段之后，可以用位段的成员名称来访问    
比移位、于、或还方便    
编译器会安排其中位的排列，不具有可移植性    
当所需的位超过一个int时候会采用多个int  
