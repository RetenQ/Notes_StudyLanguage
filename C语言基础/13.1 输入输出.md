# 输入输出

## 格式化输入输出
我们之前在```printf```和```scanf```中曾经设法规定其输入输出形式，实际上即   

***printf** 
```%[flags][width][.prec][hlL]type```   

**scanf**   
```%[flag]type```   

### printf
```%[flags][width][.prec][hlL]type```   
使用```[flags]```，有以下可填:    
```-```:左对齐。不加就是右对齐  
```+```:在前面放+或-，强制输出加号      
```(space)```:整数留空  
```0```:0填充   


使用```[width]以及[.prec]```，可填: 
```<数字>```:最小字符数，整个输出占据的位置 
``` * ```:下一个参数是字符数    
```.<数字>```:小数点之后的位数  
``` .* ```:下一个参数是小数点后的位数   
比如
9.2f:一共占据九个位置，其中小数点后占据两个位置 
```printf("%*d \n",6,123) ; ``` 一共有**6**位字符，值为**123**  

使用```[hlL]```来进行修饰，可填:    
```hh```:单个字节   
```h```: short  
```l```:long    
```ll```:long long  
```L```:long double 

#### type类型(printf)   
这部分比较多，因此单独列出  
i/d :用于int    
u : unsigned int 
o:八进制    
x:十六进制  
X：字母大写的十六进制   
f/F:float,6 
e/E:指数    
g/G:float   
a/A:十六进制浮点数  
c:char  
s:字符串    
p:指针  
n:读入/写入的个数   

### scanf   
使用```[flags]```，有以下可填:    
``` * ```:跳过  
``` <数字> ```：最大字符数  
``` hh ```: char    
``` h ``` : short   
``` l ``` : long/double 
``` ll ```：long long   
``` L ``` :long double  

#### type类型(scanf)    
d : int 
i ： 整数，可能为十六进制，可能为八进制 
u : unsigned int    
o ：八进制  
x ：十六进制    
a,e,f,g: float  
c : char    
s : 字符串(单词)   
p : 指针 
[...] :所允许的字符 

### printf和scanf的返回值   
printf:读入的项目处 
scanf:输出的字符数  

> 在要求严格的程序中，应该判断每次调用scanf或printf的返回值，从而了解程序运行中是否存在问题 

## 文件输入输出 

### 重定向: 输入<  输出>    
在终端，可以利用```>``` 和 ```<``` 作重定向输入输出 
不过一般情况还是使用```FILE```来进行重定向  

### FILE    
FILE* fopen(const char* restrict path , const char* restrict mode);
int fclose(FILE *stream);
fscanf(FILE* , ...) 
fprintf(FILE*,...)  

#### 打开文件的标准代码 
```C
FILE* fp = fopen("file" , "r");  //第一个参数是文件名，第二个参数是表明我们打开它是为了读

if(fp) { //判断是否成功打开
    fscanf(fp,...) ; //第一个参数是指向代表文件的指针，后面的参数同scanf    
    fclose(fp) ;  //关闭
}else{
    ....
}
```

**fopen的第二个参数**   
r:打开，只读    
r+:打开读写，从文件头开始   
w:打开，只写。若不存在怎新建，若存在则清空  
w+:打开读写。若不存在怎新建，若存在则清空   
a:打开追加。若不存在怎新建，若存在则从文件尾开始    
..x:在上述符号的后面可以加上该符号。只新建，如果文件已存在则不能打开(一般加在w/a后面，可以避免对已有的文件作破坏)    

## 二进制文件