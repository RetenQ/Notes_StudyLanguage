# &
&可以取出一个地址，而取出的地址的大小是由当前的架构环境所确定的

### 字节
在64位架构之下，int为4个字节，而其所对应的地址是8个字节 
在32位架构下，二者都是4个字节

### &取地址
首先它不可以对没有地址的东西取地址，比如```&(i+P)``` （i+p是变量）
换言之，必须在&的右侧，***存在一个明确的变量**，才可以去取得它的地址

对于数组而言，比如有数组a[] 
当我们取出地址时，```&a,a,a[0]```是相同的   
而相邻数组之间的差距一直为4

# 变量地址

### 指针
指针地址的变量，就是保存地址的变量  
```c
int i ; 
int* p = &i ;

//下面两行的意思是一样的
//都是p是一个地址，而q是普通的int
int* p,q;
int *p,q;
```

#### 指针变量
变量的值是内存的地址    
普通变量的值是实际的值  
指针变量的值是具体实际值的变量的地址    

### 作为参数的指针  
void f(int *p);
在被调用的时候需要了某个变量的地址  

int i = 0 ; 
f(&i);
在函数里面可以通过这个指针访问外面这个i 

### *
*是一个单目运算符，用来访问指针的值所表示的地址上的变量 
可以做右值(读)也可以做左值(写)  
```c
int k = *p ; 
*p = k+1 ;
```

## 小结
综上，我们可以使用&来取得所需要的变量的地址，而使用*来访问某个指针所指向的变量  
A.
*&a -> *(&a) -> *(a的地址) ->得到地址上的变量 -> a

B.
&*a -> &(\*a)-> &(指针所指向的变量) -> 得到a的地址

# 指针的使用    

### 使用指针交换两个变量的值
```C
void swap(int *pa , int *pb){
    int t = *pa ;
    *pa = *pb ;
    *pb = t ;
}
``` 

### 函数返回多个值  
有的时候函数返回一个值是不够的，想要函数返回多个值，某些值就只能通过指针返回    
传入的参数实际上就包含需要保存并带回结果的变量  
再次以刚才的swap函数，我们传入的两个参数需要互换值，也就说最后需要两个返回值，于是我们就需要两个指针    
> 虽然这些参数是主函数传进去的参数，但是它们作用的结果是把结果“带”出来  

#### 函数返回运算的状态，而结果通过指针返回 
实际上和前文的意思是相同的  
比如常用的情况就是让函数返回不属于有效范围内的值表示出错(比如下标是-1)  
但如果返回任何值都是有效值，就无法通过返回值来表示其结果了，于是就需要分开返回  
一般的做法是“运算状态”用函数返回，而实际的值通过指针参数来返回  
> 在java或者c++中，可以通过"异常"这个机制来解决这个问题 

### 错误警示    
在任何一个地址变量被赋值/得到一个地址 之前，不能通过它(使用*)访问任何变量   

# 指针和数组    
### 传入的数组  
实际上，在调用函数的时候，我们所传入的数组就是**一个指针**，这也是为什么在函数里面使用```sizeof```时得到的是4(32位架构) 
因为此时所谓的“数组”,其实就是一个指针   
> 事实上，如果我们把原本函数中形参的数组都改成指针，比如int a[] 改为 *a  , 并不会影响编译   

总言之，函数参数表中的数组实际上就是指针，```sizeof(a) == sizeof(int*)```,而它可以用数组的运算符[]进行运算  
所以，下面四种函数原型是等价的  
```C
int sum(int *ar,int n);
int sum(int * ,int);
int sum(int ar[] , int n);
int sum(int[] , int);s
```
**数组变量是特殊的指针**    

### 数组与数组单元
数组变量本身就可以表达地址，所以使用```int a[10] ; int*p = a ;```的时候，无需使用&来获取其地址  
但是数组内的单元,表达的都是**变量**，**需要使用&来获取地址**
另外，a == &a[0]    

[]运算符是可以对数组做，亦可以对指针做  
p[0]:当做这里有一个数组，它所指向的第一个位置就是所需的值
```C
int *p = &min ; //这里我们假设之前得到了一个最小值min
printf("*p = %d \n" , *p);
printf("p[0] = %d \n" , p[0]);
//此时二者得到的结果是一样的
```

同理，*运算符可以对指针做，亦可以对数组做   

数组变量是const的指针，也就是说它不能被赋值