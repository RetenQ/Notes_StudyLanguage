# 指针和所对应的值的cnst情况(C99)   
### 指针是const
指针是const,换言之，就是**指针是固定的**    
也就是说，该指针，指向了某个位置，这个事实是不能改变的  
```C
int *const q = &i ; //q指向了i
*q = 26 ; //可行，意思是q指针指的地方的值修改为26
q++; //ERROR,q指针自身的值不可变
```

### 所指是const    
表示的是，不能再通过**这个指针去修改那个变量**  
值得注意的是，该操作不代表“那个变量”成为来const 
```C
const int *p = &i ; 
*p = 26 ; //ERROR,在这里(*p)是一个const
i = 26 ; //是可以的，因为i本身并不是const
p = &j ; //p指针也不是const,因此可以随意更改指向
```
简而言之，就是p指针，和它所指向的变量都是可以改变的 
但是“通过p指针来修改该变量(*p)”这一方法是不可行的   

#### 判断方式
const在前面：它所指的东西不能被修改 
```c
const int* p1 = &i ; 
int const* p2 = &i ; 
```

const在后面: 表示指针不能被修改 
```c
int *const p3 = &i ;
```

#### const+指针被用于函数
比如void f(const int* x) ; 
其表示“在这个函数的范围内，保证int* x 是不会被修改的”   

# const与数组
比如const int a[] = {1,2,3,4,5,6} ; 
实际上所谓“数组变量”就已经是const的指针了   
而这里我们加入了const,代表数组内的每个单元都是const int 
所以必须且只能通过初始化来赋值  
> 所以说在把数组传到函数里面的时候，如果你不希望函数修改你的数组，则使用const

# 指针运算  
### 普通加减
对于
```C
char ac[] = {0,1,2,3,4,5,} ;
char *p = ac ; 
printf("p = %p \n",p); 
printf("p+1 = %p \n" , p+1);
```
得到的结果(示例)是  
p   = 0xbffbbd5e    
p+1 = 0xbffbbd5f    

但是如果是  
```C
int ai[] = {0,1,2,3,4,5,} ;
int *q = ai ; 
printf("q = %p \n",q); 
printf("q+1 = %p \n" , q+1);
```
得到的结果却是    
p   = 0xbffbbd2c    
p+1 = 0xbffbbd30        
差值是4 

**原因**是sizeof(char) = 1 ; sizeof(int) = 4    
所以    
**指针上的+1指的是一个sizeof()的单位**  
比如此时 *p代表的是ac[0],那么\*(p+1)代表的就是ac[1] 
> *(p+n) --> ac[n]

> 实质上，如果你的指针原先并不是指向了一片连续的空间，那么这种运算是没有意义的  

同理，也可以给指针使用+,+=,-,-=,++,--等等   

### 指针之间的运算  
两个指针是可以相减的(相加大概率没有实际意义)    
结果并不是地址的差，而是(地址差)/sizeof(),也就是说二者中间有多少"这种类型的东西"    

### *p++
意义是“取出p所指的那个数据，然后再利用指针++,把p移到下一个位置去”   
> *的优先级没有++高 
这个操作常用于数组类的连续空间操作，而在某些cpu上，这可以直接被翻译成一条汇编指令   

比如我们就可以把遍历数组的代码写为  
```c
int main(void){
    char ac[] = {0,1,2,3,4,5,6,7,-1} ; //最后一个-1表示这是数组的结尾   
    char *p = &ac[0] ; 

    while(*p != -1 ) {
        printf("%d \n" , *p++);
    }
    return 0 ;
}
```

### 指针的比较  
进行比较的操作，<,<= , == , > , >= , != 都可以被用于指针的比较  
当我们进行指针的比较的时候,比较的是**指针在内存中的地址**   
此外，数组中的单元的地址肯定是线性递增的    

### 0地址

理所当然的，我们的内存中是存在0地址的，但是这个位置通常是一个不能随便用的地址   
> 因此我们的指针不可以具有0值   

由此，我们可以利用这个特性，用0地址来表示一些特殊的事情，比如： 
1.返回的指针是无效的    
2.指针并没有被真正初始化(先初始化为0)   

在很多时候，NULL就是一个预定义好的符号，它表示0地址(在C语言的编译器里就是NULL，需要全部大写) 
> 此外，有的编译器不愿意你用0来表示0地址，因此想这么用的时候，尽量用NULL    

### 指针类型与大小  
无论指向的是什么类型，所有的指针的大小都是一样的，因为它们本质上都是地址    
但是指针存在类型的差别，**不同类型的指针是不能相互赋值的**  
(这是避免用错指针)  

不过，如果真的需要的话，是可以进行指针类型转换的    

#### 指针类型转换   
void*表示不知道指向什么东西的指针，在计算时与char\* 相同(但二者并不相通)    
指针是具有转换类型的，比如``` int *p = &i ; void*q = (void*)p ; ``` 
这种操作并没有改变p所指向的变量的类型，而是让后人以"不同的眼光"看p所指的变量    
比如这个时候，后续的程序就不认为p指向的是int,而是认为它指向了p  
(尽量不要使用)  

void* : 表示这是一个指针，但不确定它指向的是什么    

### 小结：我们可以用指针来做什么    
需要传入一个较大的数据的时候的参数  
传入数组后对数组进行操作    
函数返回不止一个结果    
需要用函数来修改不止一个变量    
动态申请内存    

# 动态分配

### 在C99之前的事   
在C99之前，我们不可以使用变量作为数组定义的大小，因此需要手动为它分配好内存 
``` int* a = (int*)malloc(n*sizeof(int)) ; ```  
下面我们就尝试一下这件事情  

> 在使用malloc之前，我们需要引入一个全新的头文件stdlib.h>   

```c
#include <stdio.h>  
#include <stdlib.h> 

int main(void) {
    int number ; 
    int* a ; 
    int i ;
    printf("请输入数量：");
    scanf("%d" , &number) ;

    //在C99，我们可以之间 int a[number] ; 来得到数组    
    
    a = (int*)malloc(number * sizeof(int)) ; //注意，我们此时要的并不是“有多少个单元”，而是“这些单元将会占据多少空间” 
    //因为malloc的结果是void*,我们还需要改变它为int*

    //然后利用指针和整数的等同性，我们这时候就直接把a当作数组使用即可
    for(i = 0 ; i <number ; i++){
        scanf("%d" , &a[i]);
    }

    for( i = number-1 , i>= 0 ; i--){
        printf("%d " , a[i]);
    }
    //当我们利用malloc得到a之后，就完完全全可以把a直接当数组使用

    //结束后需要把空间归还
    free(a);

    return 0 ;
}
```

### malloc  
来自```#include <stdlib.h>```
void* malloc(size_t size) ; 
向malloc申请的空间的大小是以字节为单位的    
返回的结果是void*,需要类型转换为自己需要的类型  
```(int*)malloc(n*sizeof(int))```  

申请失败时会返回一个0，或者NULL 

### free()
free是和malloc配套的函数，把申请来的空间重新归还给系统
只能还申请来的空间的**首地址**，也就是地址改变之后(比如p++,p--)是不可以归还的   
必须归还最开始的，申请来的那个地址  

为了配合，**建议在初始化指针的时候都给它一个0地址，如 void *p = 0;**    
如此一来，若我们在运行过程中没有使用/malloc这个指针，最终归还的时候也是free(p)也是就free(NULL)，不会报错    
> free(NULL)总是可以的      

### 常见问题
1.申请了不free  
在小程序里面当然没有影响，但是越大越重要的程序，在长时间运行中，内存就会逐渐下降    

2.free再free
要是之前已经free过了，系统会把这个地址从申请名单中删去，若是再free，就会崩溃    

3.free变过的地址
前文已经说过