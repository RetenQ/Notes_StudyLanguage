# 委托

## 初介绍委托

### 介绍
委托就是**持有一个或多个方法**的对象，并且该对象**可以执行**，也可以**传递**    
委托可以持有方法
委托可以**声明**，因为它实际上是一种引用类型    
```delegate void ActCute();```  
而且委托作为类型，我们就可以定义该类型的对象    
```ActCute actCute ; ```    
定义了一种委托类型，这种委托接受的是**没有返回值且没有参数**的方法  

### 给委托对象赋值
利用```=```和之后会说的```+=```进行赋值
```C#
class Dog{
    public void WagTail(){
        ...
    }
}

actCute = dog.WagTail ;  //注意赋值和调用是不一样的：这里不需要()
```

### 使用委托对象
就像**调用函数对象**一样使用委托    
```actCute();```    
并且委托可能持有多个方法，我们调用一次这个委托，就相当于调用了所有它所持有的方法    
第一个方法利用```=```添加，第二个使用```+=```添加   

### Lambda表达式 

可以利用delegate关键字，直接声明匿名方法给委托:
```C#
delegate void ActCute();
ActCute del ; 
del = delegate(){...};
```

而**Lambda表达式**就是一种简化这种写法的方法    
```C#
delegate void ActCute();
ActCute del ; 
del = () =>{...};
```

## 事件

### 发布-订阅
通知某件事情发生的，就是**发布者**  
对某件事情的发生关注的，就是**订阅者**  

当事件发生时，会通知所有关注该事件订阅者    
想在事件发生的时候**被通知**，就必须注册来表示关注  

> 用程序的语言来说，就是事件发生时，通知订阅者，就是调用订阅者的**注册函数**。注册，就是告诉发布者调用**哪一个注册函数**(告知调用函数/回调函数)    
> 事件，本质上和“观察者模式”是相同的

### 事件声明
因为事件触发的时候，实质上就是**调用一系列订阅者的注册函数**的事情，而我们利用委托就可以很好地完成这件事情  
使用```event```关键字来声明
```C#
delegate void Handler();
public evnet Handler NewDog;
```
(NewDog是一个成员，并且会被隐式自动初始化为null)

### 事件订阅
事件 += 方法 (订阅)
事件 -= 方法 (取消订阅)
方法可以是实例方法、静态方法、匿名方法、Lambda表达式    

### 事件触发
```C#
if(NewDog != null){
    //先检测是不是有人订阅
    NewDog();
    //如果有，就通知
}
```

### 小结
事件可以理解成是一种**封装的、受限制的委托**    

![](https://i.loli.net/2021/11/10/Ijtf1TDKsZVRpGa.png)  