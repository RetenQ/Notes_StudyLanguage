# 小结1
这部分内容主要是规范，方便各种类/方法/结构 在使用中的分类
提高了代码的整洁度和优美，而且一定程度对降低代码耦合性也有帮助
因此放在了一起

## 继承派生、虚方法、多态

### 设计原则——依赖倒置原则  
程序设计套依赖于抽象类，而不依赖于具体类  

### 基类派生类的引用 
可以引用基类来创建一个派生类的对象  
>派生类的对象包含基类部分和派生类部分  
>我们可以通过一个**基类类型**的引用指向派生类  
>通过这种方式的指向，**我们只能访问派生类中的基类部分**
```C#
Pet Dog = new Dog();
```

比如此时我调用了基类和派生类都有的一个方法Name()  
本来基类的Name()应该被隐藏而调用派生类新的Name()方法  
但是因为此时我们是利用了基类的引用而创建了该对象，所以我们只能访问基类的部分  
因此调用的还是基类的方法  

### 虚方法与多态  
虚方法：声明为**vitrual**的方法就是虚方法。基类的虚方法可以在派生类中使用**override**进行重写  

多态：通过指向派生类的**基类引用**，调用**虚函数**。根据引用所指向派生类的实际类型，调用派生类中的**同名重写函数**  

在利用虚方法和多态时，对于基类的引用时，如果你调用了一个方法  
会先判断一个方法是否是虚方法，如果是，则会查找对应的对象是否有override的方法  
如果有，则执行override方法，否则就执行基类的那个方法  

### 其它
重写虚方法必须有相同的可访问性，且基类方法不能是private  
不能重写**非虚方法** (这一点和一些语言不一样)  
不能重写static方法  
方法，属性，索引器，事件。都可以**声明为vitrual 或者override**  

## 抽象

### abstract 
抽象方法是不可以有函数体的，只存在声明    
```abstract public void func()```

> 对于虚方法而言，基类的方法仍然可用（只有子类重写了才用子类的）。而对于抽象类而言则不行。

换言之，想要用抽象方法，**必须**在子类中重写

### 抽象成员、抽象类
1.必须是**方法、属性、事件、索引**
2.使用**abstract** 修饰符标记
3.不能有实现代码块

如果一个类被abstract标记，那么它就是抽象类  
```C#
abstract class Pet
{
    ...
}
```

#### 抽象类
1.抽象类的存在只有一个目的，就是**被继承**  
2.抽象类不能被实例化，只能被abstract修饰
3.抽象类可以包含抽象成员和普通成员，以及他们的任意组合  
4.抽象类的抽象成员在派生类中需要用**override关键词**实现    

#### 实例
```C#
abstract class Pet{
    abstract public void Speak();
}

public class Dog{
    override public void Speak(){
        ...
    }
}
```

## 密闭
### sealed
密闭类:
声明为sealed的类    
不希望其他人通过**继承来修改**的类

密闭方法:
声明为sealed的方法
不希望其他人**重写**该方法

> 如果一个基类方法**不希望**子类对其重写，就可以不声明为virtual
> 如果某个派生类方法不希望子类对其重写，就可以使用sealed机制

## 接口
### 介绍
接口就是指定一组函数成员，而**不实现**他们的引用类型    
```C#
interface ICatchMice
{
    //一般名字以I开头，约定俗成的命名方式

    void CatchMice(); 
    //默认就是public 但不能加任何修饰符
}
```

可以说比“抽象类还抽象”，有点像完全没有普通函数和数据的抽象类
**接口只能被实现**

一般来说，接口就是拿去被继承的，也就是说**被别人实现的**，就像抽象类只能被用来继承  

> 接口就是定义了一个标准：“你需要实现什么事情”，而拿走这个接口的类，就需要完成这个任务

#### 接口也是一种引用类型
```C#
Cat c = new Cat();
ICatchMice ic = (ICatchMice)c ;

c.CatchMice(); //通过对象调用
ic.CatchMice(); //通过接口调用
```

### 接口特性
与抽象类相比，接口**可以实现多个接口**
我们知道，一个类只能继承与**一个父类**，但是一个类可以**实现多个接口**
```C#
Cat : Pet,ICatchMice,IClimbTree
{
    public void CatchRat(){...}
    public void ClimbTress(){...}
    ...
}
```
注意，这里的Pet是**基类/父类**，而ICatchMice,IClimbTree是**接口**
> 放在第一位的是**基类**，后面接上接口

> 无论是在接口那里实现了功能，还是在调用接口的时候忘记实现了功能（没实现接口成员），均会报错  

## 结构和类
### 结构体
```C#
struct fish
{
    int weight ; 
    int size ; 
    int type ; 
}
```

### 不同点
结构是值类型(在栈中)，类是引用类型(在堆中)
结构不支持继承，类支持继承。结构虽然不支持继承但是支持接口
结构不能定义默认构造函数，编译器会定义(结构有构造函数，但不是我们定义的)

### 适用场合
**结构**
分配内存快，作用域结束即被删除，不需要垃圾回收
作用于小型数据结构
不过，在传递过程中会复制，应该使用ref提高效率

**类**
用于其他的需要继承体系的场合

