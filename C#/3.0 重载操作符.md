# 重载操作符

## 转换和操作符重载

#### 装箱和拆箱
装箱:根据值类型的值，在堆上创建一个完整的引用类型对象，并返回对象的引用。这是一种**隐式转换**   
> 在有的时候需要将值类型转化为引用类型来进行统一的操作和统一的存储，因此我们需要装箱
> 一般而言，引用类型就是object，而统一的操作是通过“作为函数的参数传入”完成的，统一存储则是统一存储为 object[]

装箱示例:
```C#
int i = 3 ;
object oi = null ;
oi = i ;
```

> 装箱的本质就是**在堆上创建了引用类型的副本**，新创建的引用类和原来的值类型**相互独立**    


拆箱：装箱的逆操作，将装箱后的对象转换为值类型的过程，它是一种**显式转换**  

拆箱示例：
```C#
int i = 3 ; 
object oi = i ; 
int j = (int)oi;  //拆箱
```

## 自定义转换
自定义转换就是为自己的结果或者类，定义显式和隐式转换    
> 目的:为了让我们自己的结构或者类可以变成一个预期的相关的类型，并且是这种转换更加简单

### 隐式转换语法
首先是必不可少的public 和static

其次是```implicit``` 表明这是一个**隐式**的操作
```operator```代表这个是一个转换

另外，隐式转换的语法没有函数的名称，只有返回内容

比如我们想要把Cat转换为Dog
```C#
public static implicit operator Dog (Cat cat)
{
    ...
}
```

### 显式转换语法
和隐式转换的语法几乎一致    
其关键字是 ```explicit```   

```C#
public static explicit operator Dog (Cat cat)
{
    ...
}
```

## 重载运算符
利用现有的某种运算符，针对自定义类或者自定义结构，定义某种运算操作  
1.不能创造新的运算符    
2.预定义类型和现有运算符的运算含义是确定的

### why
利用现有运算符，简化自定义类型的操作    
最好是该运算符和该操作，具有一定的相关性(比如公狗+母狗=小狗)

### 语法细节
比如我们想要重载一个对于狗的加法运算

```C#
public static Dog operator +(Dog male , Dog female)
{
    ...
    return new Dog();
}
```

#### 可以重载的操作符：
**一元运算符**:+,-,!,~,++,--,true,false
**二元运算符**:+,-,*,/,%,&,|!,^,<<,>>，==，!=,>,<,>=,<=

> 不能重载: = ，&&，||，[],()

#### 重载运算符不能够做什么
创造新运算符
改变运算符的语法
重定义运算符如何处理预定义类型(比如不能把int a + int b 改为 a-b)
改变运算符的优先级和结合性  
