# 容器  
容器用于表示由同类型元素构成的、长度可变的元素序列，可以类比Java中的各种List    

## 存储
vector<元素类型>
用于需要快速定位（访问）任意位置上的元素以及主要在元素序列的尾部增加/删除元素的场合。
在头文件vector中定义，用动态数组实现    

> 类似于ArrayList，是一个可以快速读写的动态数组，空间是连续的内存空间，便于随机访问，时间复杂度为O（1）

list<元素类型>
用于经常在元素序列中任意位置上插入/删除元素的场合。 
在头文件list中定义，用双向链表实现。 

> 是一个双向的LinkList ,List查询效率较低，时间复杂度为O（n）

basic_string<字符类型>
与vector类似，不同之处在于其元素为字符类型，并提供了一系列与字符串相关的操作。 
string和wstring分别是它的两个实例：
basic_string<char>
basic_string<wchar_t>
在头文件string中定义

> 字符类型特化的vector

## 队列
deque<元素类型>
用于主要在元素序列的两端增加/删除元素以及需要快速定位（访问）任意位置上的元素的场合。
在头文件deque中定义，用分段的连续空间结构实现。

queue<元素类型>
用于仅在元素序列的尾部增加、头部删除元素的场合。
在头文件queue中定义，可基于deque和list来实现。

> 插入的地方就是队尾，所有的操作名字都与back有联系；queue只能从队首删除元素,但是两端都能访问;deque可以访问两端并且可以在队首和队尾删除和插入元素,sdeque有了push_back()和push_front(),同样，pop()是弹出，所以有pop_back()和pop_front();

priority_queue<元素类型>
它与queue的操作类似，不同之处在于：每次增加/删除元素之后，它将对元素位置进行调整，使得头部元素总是最大的。也就是说，每次删除操作总是把最大（优先级最高）的元素去掉。
在头文件queue中定义，可基于deque和vector来实现。
> 优先队列  

## 栈
stack<元素类型>
用于仅在元素序列的尾部增加/删除元素的场合。
在头文件stack中定义，可基于deque、list或vector来实现

## 表与堆   
map<关键字类型，值类型> 
multimap<关键字类型，值类型>

用于需要根据关键字来访问元素的场合。容器中每个元素是一个pair结构类型，该结构有两个成员：first和second，关键字对应first，值对应second，元素是根据其关键字排序的。
对于map，不同元素的关键字不能相同；
对于multimap，不同元素的关键字可以相同。
它们在头文件map中定义，常常用某种二叉树来实现。

set<元素类型> 和 multiset<元素类型>
它们分别是map和multimap的特例，每个元素只有关键字而没有值，或者说，关键字与值合一了。
在头文件set中定义

# 迭代器    
迭代器实现了抽象的指针（智能指针）功能，它们用于指向容器中的元素，对容器中的元素进行访问和遍
> 或者是，迭代器就是一个满足各类功能而得到的指针    

## 根据权限分类 
输出迭代器（output iterator，记为：OutIt）
可以修改它所指向的容器元素
间接访问操作（*）
++操作


输入迭代器（input iterator，记为：InIt）
只能读取它所指向的容器元素
间接访问操作（*）和元素成员间接访问（->）
++、==、!=操作。

## 根据迭代方式分类 
前向迭代器（forward iterator，记为：FwdIt）
可以读取/修改它所指向的容器元素
元素间接访问操作（*）和元素成员间接访问操作（->）
++、==、!=操作


双向迭代器（bidirectional iterator，记为：BidIt）
可以读取/修改它所指向的容器元素
元素间接访问操作（*）和元素成员间接访问操作（->）
++、--、==、!=操作


随机访问迭代器（random-access iterator，记为：RanIt）
可以读取/修改它所指向的容器元素
元素间接访问操作（*）、元素成员间接访问操作（->）和下标访问元素操作（[]）
++、--、+、-、+=、-=、==、!=、<、>、<=、>=操作
各容器的迭代器类型

### 迭代器关联  
对于vector、deque以及basic_string容器类，与它们关联的迭代器类型为随机访问迭代器（RanIt） ；  
对于list、map/multimap以及set/multiset容器类，与它们关联的迭代器类型为双向迭代器（BidIt）； 
queue、stack和priority_queue容器类，不支持迭代器    

### 特殊迭代器  
反向迭代器（reverse iterator）
用于对容器元素从尾到头进行反向遍历，可以通过容器类的成员函数rbegin和rend可以获得容器的尾和首元素的反向迭代器。
需要注意的是，对反向迭代器，++操作是往容器首部移动，--操作是往容器尾部移动


插入迭代器（insert iterator）
用于在容器中指定位置插入元素，其中包括：
back_insert_iterator（用于在尾部插入元素）
front_insert_iterator（用于在首部插入元素）
insert_iterator（用于在任意指定位置插入元素）
它们可以分别通过函数back_inserter、front_inserter和inserter来获得，函数的参数为容器 

# 算法  
STL中提供了一系列通用的对容器中元素进行操作的函数模板，称为算法     
在STL中，不是把容器传给算法，而是把容器的某些迭代器传给它们，在算法中通过迭代器来访问和遍历相应容器中的元素。**通过迭代器作为媒介，算法来描述操作** 

一个算法能接收的迭代器的类型是通过算法模板参数的名字来体现的    

## 算法的范围指出   
用算法对容器中的元素进行操作时，大都需要用两个迭代器来指出要操作的元素的范围。例如：    
```c++
void sort(RanIt first , RandIt last) ; 
// 此处需要first:第一个元素的位置 ; last：最后一个元素的下一个位置，主要是下一个位置    
```

有些算法可以有多个操作范围，这时，除第一个范围外，其它范围可以不指定最后一个元素位置，它由第一个范围中元素的个数决定。  
```c++
OutIt copy(InIt src_first, InIt src_last, OutIt dst_first); 
```
注意：  一个操作范围的两个迭代器必须属于同一个容器，而不同操作范围的迭代器可以属于不同的容器    


## 自定义条件   
有些算法可以让使用者提供一个函数或函数对象来作为自定义操作条件（或称为谓词），其参数类型为相应容器的元素类型，返回值类型为bool  
这包括两种主要的谓词：  
Pred:一元谓词，需要一个元素作为参数 
BinPred：二元谓词，需要两个元素作为参数 

> 这部分细节参照个容器/算法的使用部分   

## 自定义操作   
有些算法可以让使用者提供一个函数或函数对象作为自定义操作，其参数和返回值类型由相应的算法决定。  
这同样也包括两种自定义操作：    
Op或Fun：一元操作，需要一个参数 、
BinOp或BinFun：二元操作，需要两个参数   

> 这部分细节参照个容器/算法的使用部分   

