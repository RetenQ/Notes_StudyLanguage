# 顺序表(线性) 
## List模板 
```c
# define MAXSIZE 100    
typedef struct {
    ElemType elem [MAXSIZE] ; // 真正存数据的数组   
    int length ;// 存储当前长度 
}
``` 

类似的，也可以使用动态数组的方式来动态分配内存  
```c
# define MAXSIZE 100    

typedef struct{
    ElemType *elem ; 
    int length ; 
}SqList ; 

SqList L ; 
L.elem = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE) ;
```

## 预定义常量   
```c
// 预定义结果状态代码   
#define TRUE 1 
#define FALSE 0 
#define OK 1 
#define ERROR 1 
#define INFEASIBLE -1 
#define OVERFLOW -2 

// Status 是函数的类型，其值是函数结果状态代码  
typedef int Status ;
typedef char ElemType ; 
``` 

> C语言实现见相关c文件

## 实现(陈越版，且1为下标)
```c
# include <stdio.h>
# include <stdlib.h>
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR -1
#define ERRORPOS NULL ;
#define NOFIND NULL ;
#define INFEASIBLE -1
#define OVERFLOW -2
#define bool int ;

// Status 是函数的类型，其值是函数结果状态代码
typedef int Status ;
typedef int ElementType  ;

# define MAXSIZE 100

// 以1为下标的版本
typedef int Position ; 
typedef struct LNode * PtrToLNode ; // 
typedef PtrToLNode List ; // 定义为一个指向结构的结构指针，方便后续使用

struct LNode
{
    ElementType Data[MAXSIZE] ; 
    Position Last ; // 最后的下标，Length = Last - 1 
};

List InitList(){
    List l ; 

    l = (List)malloc(sizeof(struct LNode)) ; 
    l -> Last = -1 ;  // 初始下标是-1，因为该部分也不会放入数组
    return l  ;
}

Position Find(List L , ElementType X){
    // 按照元素查找
    Position i = 0 ; 
    while (i <= L->Last  && L->Data[i] !=X)
    {
        // 首先要找到，其次找到了就跳出来
        i++ ; 
    }
    
    // 通过实际情况返回
    if(i > L->Last) {
        // 越界了就是没找到了
        printf("没有找到") ; 
        return -1 ; 
    }else{
        return i ; //返回存储位置   
    }
}

// 插入
// 插入是指在表的第i个位次上加入一个新元素，或者说在第i个元素之前插入新元素
// 1.将第i到n个元素顺序后移， 2.将X元素插入第i个次序  ， 3.修改Last

bool Insert(List L  , ElementType x , int i ){
    Position j ; 
    if(L->Last == MAXSIZE -1 ){
        // 表空间已经满了
        printf("表空间已满");
        return FALSE ; 
    }

    if(i<1 || i > L->Last+2){
        printf("插入位次不合法"); // 注意，这是插入0也是不合法的。因为是从1开始算的（数组是从0开始算的）
        return FALSE ; 
    }

    for(j = L->Last ; j >= i-1 ; j--){
        L->Data[j+1] = L->Data[j] ; // 开始移动，方式是将j的元素移到j+1,知道i-1为止（此时把i-1移动到了i）
    }

    // 进行插入操作 
    L->Data[i-1] = x ; 
    L->Last++ ; 
    return TRUE ; 
}

// 删除 
// 设在i位置的元素被删除 1.把i+1 - n 的元素向前移动， 2. ai被ai+1覆盖 ， 3.修改Last

int Delete(List L ,int i ){
    Position j ;

    if(i <1 || i > L->Last+1){
        printf("位次错误");
        return FALSE ;
    }

    for(j = i ; j <= L->Last ; j++){
        L->Data[j-1]  = L->Data[j] ; 
    }

    L->Last -- ; 

    return TRUE; 
}

// 带取出
int Delete(List L ,int i ,int* data){
    // 这里还附带一个取出
    Position j ;

    if(i <1 || i > L->Last+1){
        printf("位次错误");
        return FALSE ;
    }

    data = L->Data[i] ; 

    for(j = i ; j <= L->Last ; j++){
        L->Data[j-1]  = L->Data[j] ; 
    }

    L->Last -- ; 

    return TRUE; 
}

int main(){
    List l = InitList() ; 

    return 0 ;

}

```

## 实现(0为下标) 
```c
# include <stdio.h>
# include <stdlib.h>
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 1
#define INFEASIBLE -1
#define OVERFLOW -2

// Status 是函数的类型，其值是函数结果状态代码
typedef int Status ;
typedef int ElemType ;

# define MAXSIZE 100

typedef struct{
    ElemType elem[MAXSIZE] ;
    int length ;
}SqList ;

// 基础操作=================================
// 线性表初始化
Status InitList_Sq(SqList *L){

    // int temp [MAXSIZE] ;
    // L->elem = temp ;
    // if(!L->elem) {
    //     exit(OVERFLOW) ;
    // }


    L->length  = 0 ;

    return OK ;
}

// 销毁
void DestoryList(SqList *L){
    if(L->elem) {
        free(L->elem) ;
    }
}

// 清空
void ClearList(SqList *L){
    L->length = 0 ;
}

int GetLength(SqList *L){
    return L->length ;
}

int isEmpty(SqList *L){
    // return (L->length == 0) ;

    if(L->length == 0){
        return 1 ;
    }else{
        return 0 ;
    }
}

// 基本操作=================================
// 取值
int GetElem(SqList L , int i , ElemType *e){
    if(i < 0 || i >=  L.length )  {
        printf("ERROR !");
        return ERROR ; //如果越界
    }
    // 这里认为下标都是由0算起

    // printf("get : %d" ,L.elem[i] );
    *e = L.elem[i] ; // 获得元素，通过指针放到e里面去
    return OK ;
}

// 查找
int LocateElem(SqList L ,ElemType e){
    int i ;
    for(i = 0 ; i < L.length ; i++){
        if(L.elem[i] == e) return i ; // 这里因为都是按0作为下标，因此返回i即可
    }

    return -1 ; // 查找失败返回-1
}

// 插入有不同的情况，包括在最后，在中间，在最前面
// 第二是表已经满了，这时候要考虑溢出情况
// 1.插入的位置是否合法  2.判断空间是否已经已满 3.插入到i，将n到i位的元素都依次向后移动一个位置，然后放入并让length+1

Status ListInsert_Sq(SqList *L , int i , ElemType e){

    // 这里要用指针引用SqList以改变其内部情况


    if(i < 0 || i >= L->length+1 ) return ERROR ;

    if(L->length == MAXSIZE) return ERROR ;
    int j ;

    for(j = L->length -1 ; j >= i ;j--){
        L->elem[j+1] = L->elem[j] ;

    }


    L->elem[i] = e ;

    L->length++;

    return OK;
}

// 线性表删除
// 删除指的就是把第i个结点删除，使长度为n的线性表变成长度为n-1的表
// 1.判断删除位置是否合法  2.将删除的元素保留到e中(可选) 3.将i+1到n的元素全向前移动一个单位，length--
Status ListDelete_Sq(SqList *L , int i){
    printf("DL : %d , length : %d \n" , i , L->length) ;
    if(i < 0 || i >= L->length ) {
         // 都是从下标0开始记的，所以最大删除第length-1位
        printf("Error!");
        return ERROR ;
    }
    int j ;
    int length = L->length ;
    int theMin = length -1 ;
    for(j = i ; j<= theMin ; j++){
        L->elem[j] = L->elem[j+1] ;
    }


    L->length--; // length--就相当于处理掉最后一位了

    printf("删除后的length: %d \n" , L->length) ;

    return OK ;
}


// ============================
// 这是写的测试遍历的函数
void TestList(SqList *L){
    int i ;
    int length = L->length ;
    int temp = 0 ;
    for(i = 0 ; i < length ; i++){
        GetElem(*L,i,&temp);
        printf("%d ",temp);
    }

    printf("\n  Now Length : %d  \n" , length);

}

/*遍历操作*/
void PrintList(SqList *l)
{
	for (int i = 0; i < l->length; i++)
		printf("%d ", (l->elem[i]));
}

int main(){
    int i ;
    SqList L ;
    InitList_Sq(&L) ;  // 初始化
    //TestList(&L);
    for(i = 0 ; i <= 10 ; i++){
         ListInsert_Sq(&L , i , i) ; //插入
    }

    TestList(&L);

    printf("测试把-1插入到下标为1的位置 \n");

    ListInsert_Sq(&L , 1 , -1);
    TestList(&L);

    printf("测试把-2插入到下标为3的位置 \n");
    ListInsert_Sq(&L , 3 , -2);
    TestList(&L);

    printf("\n");

    printf("删除第0位，第3位的元素，最后一位（依次） \n");

    ListDelete_Sq(&L , 0);
    TestList(&L);
    ListDelete_Sq(&L , 3);
    TestList(&L);
    ListDelete_Sq(&L , L.length-1);
    TestList(&L);


     //PrintList(&L);


    return 0 ;

}
``` 

## 小结 
查找、插入、删除算法的平均时间复杂度是O(n)  
顺序表操作算法的空间复杂度S(n) = O(1),其没有占用辅助空间    

优点:   
1.存储密度大 （结点本身所占存储量 / 结点结构所占存储量）    
2.可以随机存取表中任一元素  

缺点：  
1.插入、删除某一元素时，需要移动大量元素    
2.浪费存储空间  
3.属于静态存储形式，数据元素的个数不能自由扩充  

# 顺序表（链式）  
用一组物理位置任意的存储单元来存放线性表的数据元素  
这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存的任意位置上的    
链表元素的逻辑次序和物理次序不一定相同  

各个结点由两个域组成：  
1.数据域：存储元素数值数据  
2.指针域：存储直接后继结点的存储位置    

结点只有一个指针域，称为单链表；有存前后两个指针域的，称为双链表；首尾相接的链表尾循环链表  

无头结点时，头指针为空时表示空表；有头结点时，当头结点指针域为空时表示空表  

## 实现 
注：该实现中默认第一位为空的头结点0 

```c
# include <stdio.h>
# include <stdlib.h>
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 1
#define ERRORPOS NULL ;
#define NOFIND NULL ;
#define INFEASIBLE -1
#define OVERFLOW -2
#define bool int ;

// Status 是函数的类型，其值是函数结果状态代码
typedef int Status ;
typedef int ElementType  ;

# define MAXSIZE 100

typedef struct LNode * PtrToLNode ;

struct LNode
{
    ElementType Data ;
    PtrToLNode  Next ;
};

typedef PtrToLNode Position ; // 结点的地址
typedef PtrToLNode List; //

// 基础操作
List InitList(){
    List tmpL = (PtrToLNode)malloc(sizeof(PtrToLNode)) ;
    tmpL->Next = NULL ;// 最开始的“下一个”是NULL
    return tmpL ;
}

// 求表长
int getLength(List L){
    Position p ;
    // ! 注意，List L是头指针，是不可以动的，因此需要另外一个指针来协助进行遍历
    int cnt = 0 ;
    p = L ; // 利用一个指针p进行遍历

    while (p)
    {
        p = p->Next;
        cnt++ ;
    }

    return cnt;

}

// 序号查找(获得元素)
ElementType FindKthEle(List L , int k){
    Position p ;
    int cnt = 1 ; // 位序从1开始
    p = L ;  // p指向L的第1个节点

    while (p && cnt < k)
    {
        p = p->Next;
        cnt ++ ;
        // 一直向前计直到到达第k个
    }

    if((cnt == k) && p ){
        return p->Data ; // 返回数据
    }else{
        return FALSE ;
    }

}

// 序号查找(获得地址)
Position FindKthPos(List L , int k){
    Position p ;
    int cnt = 1 ; // 位序从1开始
    p = L ;  // p指向L的第1个节点

    while (p && cnt < k)
    {
        p = p->Next;
        cnt ++ ;
        // 一直向前计直到到达第k个
    }

    if((cnt == k) && p ){
        return p ; // 返回数据
    }else{
        printf("该地址查找失败");
        return NOFIND ;
    }

}


// 按值查找(获得地址)
Position FindElem(List L , ElementType X){
    Position P = L ;

    while (P && P->Data != X)
    {
        P = P->Next ;
    }

    // 跳出循环有两个情况，一是到头了，二是找到了
    if(P && P->Data == X){
        // P还有指向，那就是找到了
        return P;
    }else{
        return NOFIND ; //没找到，就返回NULL
    }

}

// 插入和删除

// 插入操作
// 1.构造应该新结点，用S指向 2.找到链表的第i-1个结点，用P指向 3.修改指针（利用P指针），完成插入

List InsertSelf (List L , ElementType X , int i ){
    // 这里是不使用“Findkth”的查找法
    Position tmp , pre ;

    // 准备新结点
    tmp = (Position)malloc(sizeof(struct LNode)) ;
    // 这里要拿到的空间是结点，不是数据元素，注意了
    tmp->Data = X ;

    // 表头插入，插表头，返回新表头的Node
    if(i == 1 ){
        tmp->Next = L ; // 指向原表头
        return tmp ;  // 插入的元素成为了新表头
    }else{
        // 查找i-1位置的结点，即FindKth(i-1 , L) ;
        int cnt = 1  ; pre = L ;
        while (pre && cnt < i -1 )
        {
            pre = pre -> Next ;
            cnt++ ;
        }

        if(pre == NULL || cnt != i-1){
            printf("查找失败") ;
            free(tmp) ;
            return NULL ;
        }
        //==============================================
        else{
            // 成功查找到，按计划进行插入
            tmp -> Next = pre -> Next ;
            pre -> Next = tmp ;

            return L ; //
        }
    }
}

// 调用了FindKth的插入算法
List InsertKth (List L , ElementType X , int i ){
    // 这里是不使用“Findkth”的查找法
    Position tmp , pre ;

    pre = L ; // 设置pre为表头（如果tmp）

    // 准备新结点
    tmp = (Position)malloc(sizeof(struct LNode)) ;
    // 这里要拿到的空间是结点，不是数据元素，注意了
    tmp->Data = X ;

    // 表头插入，插表头，返回新表头的Node
    if(i == 1 ){
        tmp->Next = L ; // 指向原表头
        return tmp ;  // 插入的元素成为了新表头
    }else{
        pre = FindKthPos(L , i-1) ;
        if(pre == NULL){
            return NULL ; //查找失败
        }
        else{
            // 成功查找到，按计划进行插入
            tmp -> Next = pre -> Next ;
            pre -> Next = tmp ;

            return L ; //
        }
    }
}

// 带头结点的插入方式
// 这种插入方式可以保证无论在哪里插入或者删除，L的值一直有指向固定的空的结点
int Insert(List L , ElementType X , int i){
    // 默认头结点是已经被初始化过的
    Position tmp,pre ;

    // 查找i-1结点
    pre = FindKthPos(L , i-1) ;

    if(pre == NULL){
        //没有找到
        printf("插入位置参数错误\n") ;
        return FALSE ;
    }else{
        // 找到的情况
        tmp = (Position)malloc(sizeof(struct LNode)) ;
        tmp->Data  = X ;
        tmp->Next = pre->Next ;
        pre->Next = tmp ;

        return TRUE ;
    }
}


// 删除操作
// 1. 找到链表的第i-1个结点，用p指向  2.再用一个辅助指针s指向要删除的结点  3.修改指针完成删除操作  4.释放s所指结点的空间（也就是释放被删除掉的结点的空间）
int Delete(List L , int i){
    // 这里是默认有头结点的
    Position s , pre ;

    /* 查找位序为i-1的结点 */
    pre = FindKthPos(L , i-1) ; //

    if(pre == NULL || pre->Next == NULL){
        // 如果删除的结点没找到（pre的next是NULL，也是代表没找到要删的东西）
        // 这个比插入的时候多了一个条件判断
        printf("删除位置参数错误") ;
        return FALSE ;
    }else{
        // 找到
        s = pre->Next ; //用s指向要删除的地方，为了之后可以free
        pre->Next = s->Next ; // 将删除元素的后面的元素连在它前面的元素上
        free(s) ; //free删除的元素
        return TRUE ;
    }
}


void ShowList(List L ){
    Position p = L  ;
    printf("===================================== \n");

    while(p){
        int tmp = p->Data ;
        printf("%d -> " , tmp );
        p = p->Next ;
    }

    printf("\n===================================== \n");

}


int main(){
    List l = InitList();

    printf("t") ;
    l->Data = 0 ;

    printf("测试初始长度: N1 : %d （含头结点） \n" , getLength(l));
    ShowList(l);

    printf("测试插入(都以带头结点的插入删除为准)");
    InsertSelf(l,123,2); //
    ShowList(l);
    InsertKth(l,456,3);
    ShowList(l);
    Insert(l,789,4);
    ShowList(l);
    Insert(l,1357,5);
    ShowList(l);
    Insert(l,2468,6);
    ShowList(l);
    printf("额外测试：在第3位插入333 \n");
    Insert(l,333,3);
    ShowList(l);
    printf("测试初始长度: N1 : %d （含头结点） \n" , getLength(l));
    printf("依次删除第二位，第四位 \n");
    Delete(l,2);    ShowList(l);
    Delete(l,4);    ShowList(l);

    return 0 ;
}

```

# 广义表    
是线性表的一种推广  
可以理解为一个既可以存储元素（原子），也可以存储另外一个表（子表）的特殊的表    
通常用链式表的结构来实现广义表  

## 概念 
广义表通常记成 LS = (a1,a2,...,an) ;    
LS是**表名**,n是表的长度，每一个ai为表的元素    
**表头：**若LS非空，那么第一个元素a1是表头（表头可以是原子，也可以是子表）
**表尾：**除表头以外，其它元素组成的一个表  
> 也就是说，表尾不是最后一个元素，而是一个子表  

**长度：**最外层所包含的元素的个数  
**深度：**广义表展开后所含括号的重数【B=((b,c),d)，深度为2】    
原子的深度为0，空表的深度为1，长度为0   
广义表可以是一个递归的表，比如F=(a,c,F) ,递归表的深度是无穷值，长度是有限值 


其结构类似于：  
```c
typedef struct GNode * PtrToGNode ; 
typedef PtrToGNode GList ; 

struct GNode
{
    int Tag ; //0表示是单元素，1表示是表

    union 
    {
        ElementType Data ; 
        GList SubList ; 
    } URegion;

    PtrToGNode Next ; //指向后继结点    
};
```

# 多重链表  
存在“链表中的结点可能同时于多个链”的情况的结点链表是多重链表    
多重链表中结点的指针域会有多个，但是包含了两个指针域的链表不一定是多重链表      

多重链表有广泛的用途，比如树、图等，这个见相关的笔记部分    