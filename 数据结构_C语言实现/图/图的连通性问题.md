# 连通性问题    

# 最小生成树    
最小生成树存在，图一定连通  

> 没必要专门使用树的结构来存，使用一个数组来存每一个点的parent即可  

## Prim算法 
一步步生成最小生成树    

```c
#define ERROR -1    
#define INFINITY 65535  //最大值，表示无限即两个点不相连   

// 寻找最短Dist
Vertex FindMinDist(MGrapg Graph , WeightType dist[]){
    Vertex MinV , V ; 
    WeightType MinDist = INFINITY ; 

    for(V = 0 ;V < Graph->Nv ; V++){
        if(dist[V] != 0 && dist[V] <MinDist){
            MinDist = dist[V] ; 
            MinV = V ; 
        }
    }

    if(MinDist < INFINITY){
        return MinV ; 
    }else{
        return ERROR ; 
    }
}

int Prim(MGraph Graph , LGraph MST){
    // 将最小生成树保存为邻接表存储的图MST  
    WeightType dist[MaxVertexNum] , TotalWeight ; 
    Vertex parent[MaxVertexNum] , V,M ;
    int Vcount ; 
    Edge E ; 

    // 初始化
    for(V = 0 ; V <Graph->Nv ; V++){
        dist[V] = Graph->G[0][V] ; 
        parent[V] = 0 ; 
    }

    TotalWeight = 0 ; 
    VCount = 0 ; 

    // 创建图
    MST= CreateGraph(Graph->Nv) ; 
    E = (Edge)malloc(sizeof(struct ENode));
    
    // 收录初始点
    dist[0] = 0 ; 
    Vcount++ ; 
    parent[0] = -1 ; 

    while(1){
        V = FindMindDist(Graph, dist) ;  // 得到最小边的顶点V

        if(V == ERROR)  break ; 

        // 设置加入的边 VParent->V ,权重为Weight
        E->V1 = parent[V] ;  //
        E->V2 = V ; 
        E->Weight =dist[V] ; 
        InsertEdge(MST , E) ;
        TotalWeight += dist[V] ; 
        dist[V] = 0 ; VCount++ ;

        for(W = 0 ; W < Graph->Nv ; W++){
            if(dist[W]!=0 && Graph->G[V][W] < INFINITY){
                // 开始遍历V的每个邻接点并判断  
                if(Graph->G[V][W]  < dist[W]){
                    dist[W] = Graph->G[V][W] ; //更新dist 
                    parent[W] = V  ; //更新距离
                }
            }
        }
    } 

    // while结束代表从起始点开始的尝试结束  
    // 此时检查是否得到了最小生成树

    if(VCount  < Graph ->Nv)    TotalWeight = ERROR ; 

    return TotalWeight ; 
}

```

## Kruskal算法  
将森林合并成树  
在Kruskal里面，MST收集的是边而非顶点    
由于Kruskal所要的前置数据结构过多，这里（和书里）只提供伪代码   

```c
int Kruskal(LGtaph Graph , LGraph MST){
    //
    MST = {包含所以顶点但没有边的图} ; 
    while(MST中收集的边不到Graph->Nv-1  && 原图的边集合E != NULL){
        1.从E中选择最小代价边(使用最小堆)   
        2.从E中删除此边

        if((V,W)的选取不在MST中构成回路){
            (V,W)加入MST； 
            // 判断“构成回路”使用并查集的FIND，加入MST使用并查集的Union 
        }else{
            丢弃(V,W);
        }

        // 同样进行检查 
        if(MST中收集的边不到Graph->Nv-1) return ERROR ; 
        else return MinWeight ;
    }
}
```

