# 最短路径  

## 单源最短路径 
### 无权
无权图的单源最短路径根据BFS魔改一下即可，其伪代码类似： 
```c
void UnWeighted_Find(Vertex S){
    EnQueue(S,Q) ; 
    while(!IsEmpty(Q)){
        V = Dequeue(Q) ; 

        for(V的每个邻接点W){
            // 一般采用邻接链表存储 
            if(dist[w] == -1){
                //dist是w点到源点的距离
                // 在无权图中我们用一个特殊的数值表示其未访问过即可 
                dist[w] = dist[v]+1 ; 
                path[w] = v ; 
                //path记录“到达w的必经点”也就是w的上一个顶点
                // 需要输出路径的情况下，可以利用一个Stack来输出结果
                Enqueue(W,Q) ;
            }
        }
    }
}
```

### 有权
采用dijkstra算法计算有权图的单源最短路径    
核心：```dist[w] = min{dist[w] , dist[v] + <v,w>}```    
```c
// 浙大版   
Vertex FinMinDist(MGraph Graph , int dist[] , int collected[]){
    // 用于返回“未收录顶点”的最小者 
    Vertex MinV , V ; 
    int MinDist  = INFINITY ; 

    for(V=0 ; V < Graph->Nv ; V++){
        // 遍历V并寻找
        if(collected[V]==FALSE && dist[V] < MinDist){
            // 记录最小距离和对应的点
            MinDist = dist[V] ; 
            MinV = V ;
        }
    }

    if(MinDist <INFINITY)   return MinV ; //还能找到最小值  
    else return ERROR ; // 返回错误标记 
}

bool Dijkstra(MGraph Graph, int dist[] , int path[] , Vertex S){
    int b[MaxVertexNum] ; //标记数组    
    Vertex V , W ;

    // 初始化：把边读入（这里默认了在Graph已经把不存在的边标记为了INFINITY）
    // 其次是设置路径path和标记数组
    for(V = 0  ; V < Graph->Nv ; V++){
        dist[V] = Graph->G[S][V] ; //与目标点直接相连的顶点 
        path[V] = -1 ; b[V] = FALSE ;
    }

    // 收入起点 
    dist[S] = 0 ; b[S] = TRUE ;

    // 算法核心
    while(1){
        // 寻找“未收录顶点”的最小者 
        V = FinMinDist(Graph , dist , b) ;
        if(V==ERROR){
            // 没找到的情况，代表循环应该结束   
            break;
        }
        //
        // 否则收人V并更新
        b[V] = TRUE ; 
        for(W = 0 ; W< Graph->Nv ; W++){
            // 检查W，需要更新的W满足以下条件   
            // 1.是V是邻接点  2.未被b收录
            if(b[W] == FALSE &&  Graph->G[V][W] < INFINITY){
                if(Graph ->G[V][W] < 0) return FALSE ;//不能有负边的情况的

                // 判断是否更新
                if(dist[V] + Graph[V][W] < dist[W]){
                    // 找到了新的更小值就更新   
                    dist[W] = dist[V] + Graph[V][W] ; 
                    path[W] = V ; // V是新的更小点  
                }
            }
        }

    } // END WHILE

    return TRUE ; 
}
```


```c
// 清华版
void ShortestPath_DIJ(MGraph G , int V0, PathMatrix* P , ShortPathTabel* D){
    // 图 ， 起点 ，P最短路径 ， D带权长度    
    // P[V][W] = TRUE , 则w是从v0到v当前求得最短路径上的顶点    
    // final[V] = TRUE ; 当且仅当已经求得V0到V的最短路径    

    for(v = 0 ; v < G.vexnum ; ++v){
        final[v] = FALSE ;  // 首先先将每一个
        D[v] = G.arcs[v0][v] ; 

    for(w = 0 ; w< G.vexnum ; ++w)  p[v][v] = FALSE ;  // 先设置空路径  

        if(D[V] < INFINITY){
            P[v][v0] = TRUE ; 
            p[v][v] = TRUE ; 
        }
    }

    D[V0] = 0 ; final[v0] = TRUE ; // 初始化，v0顶点属于S集 

    //开始主循环，算法的核心    
    // 每次循环得到一个v0到v的最短路径，然后加入S集
    for(i=1 ; i <G.vexnum;++i){
        min = INFINITY ; 

        for(w = 0 ; w<G.vexnum ;++w){
            if(!final[w])
                if(D[w] < min){
                    // w顶点更近的情况
                    v = w ; 
                    min = D[w] ; 
                }
        }

        final[v] = TRUE ; 
        for(w=0;w<G.vexnum; ++w){
            // 进行更新
            if(!final[w] && (min+G.arcs[v][w] < D[w])){
                D[w] = min + G.arcs[v][w] ; 
                P[w] = P[v] ; 
                P[w][w] = TRUE ;  // P[W] = P[V]+[W]
            }
                
        }
    }

}
```

## 多源最短路   
```c
bool Floyd(MGraph Graph , WeightType D[][MaxVertexNum] , Vertex path[][MaxVertex-Num]){
    // 图 ， 距离值 ， 路径结果
    Vertex i,j,k ; 

    // 初始化
    for(i=0 ; i < Graph->Nv ; i++)
        for(j=0 ; j  < Graph->Nv ; j++){
            D[i][j] = Graph->G[i][j] ; 
            path[i][j] = -1 ; 
        }

    for(k=0 ; k <Graph->Nv;k++)
        for(i=0 ; i < Graph->Nv ; i++)
            for(j=0 ; j  < Graph->Nv ; j++){
                // 检查与更新   
                if(D[i][k] + D[k][j] < D[i][j]){
                    D[i][j] = D[i][k] + D[k][j] ;
                    if(i==j && D[i][j] < 0 ){
                        // 处理负值圈   
                        return FALSE
                    }

                    // 正常情况则记录新的ijk
                    path[i][j] = k ; // 意思是从i->j的最短路径现在经过k
                }
            }
    return TRUE ; 
}

```

```c
// 清华版
void ShortestPath_FLOYD(MGrapg G , PathMatrix * p[] , DistanceMatrix * D){
    // D是带权路径
    // P[v][w][u] = TRUE , 代表u是从v->w最短路径上的点

    // 初始化
    for(v = 0 ; v <G.vexnum ; ++v){
        for(w = 0 ; w <G.vexnum ; ++w){
            D[v][w] = G.arcs[v][w] ; 

            // 初始化路径情况
            for(u = 0;u<G.vexnum ; ++u)     P[v][w][u] = FALSE ;

            //设置已有路径  
            if(D[v][w] < INFINITY){
                p[v][w][v] = TRUE ;
                P[v][w][w] = TRUE;
            }
        }
    }

    // 进行核心算法
    for(u=0 ; u<G.vexnum ; ++u)
        for(v=0 ; v<G.vexnum ; ++v)
            for(w=0 ; w<G.vexnum ; ++w){
                // 进行更新判断 
                if(D[v][u] + D[u][w] < D[v][w]){
                    D[v][w] = D[v][u] + D[u][w] ;
                    for(i = 0 ; i<G.vexnum;++i){
                        P[v][w][i] = P[v][u][i] || P[u][w][i] ; 
                    }
                }
            }

}
````
