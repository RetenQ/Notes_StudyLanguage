# 最短路径  

## 单源最短路径 
```c
void ShortestPath_DIJ(MGraph G , int V0, PathMatrix* P , ShortPathTabel* D){
    // 图 ， 起点 ，P最短路径 ， D带权长度    
    // P[V][W] = TRUE , 则w是从v0到v当前求得最短路径上的顶点    
    // final[V] = TRUE ; 当且仅当已经求得V0到V的最短路径    

    for(v = 0 ; v < G.vexnum ; ++v){
        final[v] = FALSE ; 
        D[v] = G.arcs[v0][v] ; 

        for(w = 0 ; w< G.vexnum ; ++w)  p[v][v] = FALSE ;  // 先设置空路径  

        if(D[V] < infinity){
            P[v][v0] = TRUE ; 
            p[v][v] = TRUE ; 
        }
    }

    D[V0] = 0 ; final[v0] = TRUE ; // 初始化，v0顶点属于S集 

    //开始主循环，算法的核心    
    // 每次循环得到一个v0到v的最短路径，然后加入S集
    for(i=1 ; i <G.vexnum;++i){
        min = INFINITY ; 

        for(w = 0 ; w<G.vexnum ;++w){
            if(!final[w])
                if(D[w] < min){
                    // w顶点更近的情况
                    v = w ; 
                    min = D[w] ; 
                }
        }

        final[v] = TRUE ; 
        for(w=0;w<G.vexnum; ++w){
            // 进行更新
            if(!final[w] && (min+G.arcs[v][w] < D[w])){
                D[w] = min + G.arcs[v][w] ; 
                P[w] = P[v] ; 
                P[w][w] = TRUE ;  // P[W] = P[V]+[W]
            }
                
        }
    }

}
```

## 多源最短路   

```c
void ShortestPath_FLOYD(MGrapg G , PathMatrix * p[] , DistanceMatrix * D){
    // D是带权路径
    // P[v][w][u] = TRUE , 代表u是从v->w最短路径上的点

    // 初始化
    for(v = 0 ; v <G.vexnum ; ++v){
        for(w = 0 ; w <G.vexnum ; ++w){
            D[v][w] = G.arcs[v][w] ; 

            // 初始化路径情况
            for(u = 0;u<G.vexnum ; ++u)     P[v][w][u] = FALSE ;

            //设置已有路径  
            if(D[v][w] < INFINITY){
                p[v][w][v] = TRUE ;
                P[v][w][w] = TRUE;
            }
        }
    }

    // 进行核心算法
    for(u=0 ; u<G.vexnum ; ++u)
        for(v=0 ; v<G.vexnum ; ++v)
            for(w=0 ; w<G.vexnum ; ++w){
                // 进行更新判断 
                if(D[v][u] + D[u][w] < D[v][w]){
                    D[v][w] = D[v][u] + D[u][w] ;
                    for(i = 0 ; i<G.vexnum;++i){
                        P[v][w][i] = P[v][u][i] || P[u][w][i] ; 
                    }
                }
            }

}
````
