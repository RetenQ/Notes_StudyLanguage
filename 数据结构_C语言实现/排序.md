# 插入排序  
最好情况 ： O(N)  , 均是顺位    
最好情况 ： O(N^2)  , 均是逆序  

插入排序是比较稳定的一种排序方式    

## 简单插入排序
简单插入排序的核心思想是：将待排序的一组序列分为已排好序的和未排好序的两部分    


```c
# include <stdio.h>
# include <stdlib.h>

#define FALSE 0;
#define TRUE 1   ;
#define ERROR -1 ;

typedef int ElementType ;
typedef int bool ;

// 插入排序 
void InserionSort(ElementType A[] , int N){
    // 认为结果数组是从小到大排序的

    int P , i ;
    ElementType tmp ; 

    // 逐步遍历未排序序列的元素
    for(P=1;P<N;P++){
        tmp = A[P] ; // 取出未排序数组的第一个元素  

        for(i=P ; i>0 && A[i-1]>tmp ; i--)
        {
            // 从尾部开始，直到找到一个"tmp比它大"的位置插入
            // 因此比tmp大的部分都需要后移
            A[i] = A[i-1] ; 
        }

        A[i] = tmp ; // 放入合适位置    
    }
}
```

## 希尔排序
希尔排序的核心则在于加入了**间隔**，即改成对每D个元素进行排序，然后递减D    
简易的希尔排序D_k = (D_k+1) / 2 。有的时候它并不理想    

这里的代码实现使用了SedgeWick增量序列来进行希尔排序 

```c
void ShellSort(ElementType A[] , int N){
    int Si , D, P , i ; 

    ElementType Tmp ; 

    // 定义SedgeWick增量序列（这里只使用一部分）    
    int SedgeWick[]={929,505,209,109,41,19,5,1,0};
    for(Si = 0 ; SedgeWick[Si] >= N ; Si++); //设定初始增量的长度   

    for(D=SedgeWick[Si] ; D>0 ; D= SedgeWick[++Si])
        for(P = D ; P< N ;P++){
            Tmp = A[P] ; 
            for(i = P ; i>=D && A[i-D] > Tmp ; i-=D)
                A[i] = A[i-D] ; 

            A[i] = Tmp ; 
        }
}
```

# 选择排序  
## 简单选择排序 
简单选择排序就是最基本的做法，找到最小值，然后交换，一直持续下去    
**找到最小值**的部分直接使用遍历查找    
其实现如下: 
```C
void Swap(ElementType *a , ElementType *b){
    ElementType t = *a ; 
    *a = *b ; 
    *b = t ; 
}

// 简单选择排序 
void SimpleSelectionSort(ElementType A[] , int N){
    int i ,j ,min ; 

    for(i = 0 ; i <N-1 ; i++){
        min = i ; 
        for(j = i+1 ; j <N;j++)
            if(A[j] < A[min])   min = j ; // 不断记录最小元素的位置

        
        Swap(&A[i] , &A[min]) ; 
    }
}
``` 

## 堆排序   
! 注意之前生成最大堆的代码不能直接调用，但是核心思路是一样的    
因为这里的数据在第0个单元开始存放   

```c
void Swap(ElementType *a , ElementType *b){
    ElementType t = *a ; 
    *a = *b ; 
    *b = t ; 
}

void PercDown(ElementType A [] , int p , int N){
    // 将N个元素的数组中，以A[p]为根的子堆调整为最大堆
    int Parent , Child ; 
    ElementType X  ;

    X = A[p] ; //取出根结点存放的数值   

    for(Parent = p ; (Parent*2 + 1) < N ; Parent  =Child) {
        // 因为初始下标为0，所以更新的Parent都是2t+1了
        Child = Parent *2 + 1 ;
        if((Child != N-1) && (A[Child] < A[Child+1]))
            Child++ ; 
        
        if(X >= A[Child])   break; 
        else A[Parent] = A[Child] ; 
    }

    A[Parent] = X ; 
}


void HeapSort(ElementType A[] , int N){
    int i ;

    for(i = N-1 ; i>0;i--){
        Swap(&A[0] , &A[i]) ; 
        PercDown(A,0,i) ; 
    }
}
``` 
# 冒泡排序  
经典排序方法，不赘述 
```C
void Swap(ElementType *a , ElementType *b){
    ElementType t = *a ; 
    *a = *b ; 
    *b = t ; 
}

// 冒泡排序 
void BubbleSort(ElementType A[] , int N){
    int P , i ; 
    bool flag ; 

    for(P = N-1 ; P >= 0 ; P--){
        flag = FALSE ;  // 每次开始都置为FALSE 

        for(i = 0 ; i < P ; i++){
            // 一趟趟进行，每次找出一个最大元素就交换到最右端   
            if(A[i] > A[i+1]){
                Swap(&A[i] , &A[i+1]) ; 
                flag = TRUE ;  // 标记发生了交换
            }
        }

        // 全程无交换就代表完成，跳出
        if(flag == TRUE ) break; 
    }
}
```

# 快速排序  
快速排序也是交换排序的一种  
它的核心在于选择一个pivot(主元)，根据主元将数组划分为两个子序列，一个大，一个小 
在不断的分治中，问题的规模变小，最终得到处理    
> pivot的选取有很多种方式，甚至有专门的算法。这里就先默认第一个下标的值是pivot了

```c

void Swap(ElementType *a , ElementType *b){
    ElementType t = *a ;
    *a = *b ;
    *b = t ;
}

// 快速排序

// 核心排序函数，用于递归
void Qsort(ElementType A[] , int Left , int Right){
    int Pivot  , Low , High ;
    // int Cutoff ; //可以设置Cutoff来决定是否快排，这里不设置了
    // Low从最小的下标开始，High则最大的下标开始

        Pivot = A[0] ;
        Low = Left ;
        High = Right -1 ;

        // 移动。大的放右边，小的放左边
        while (1)
        {
            // 移动脚本
            while(A[++Low] < Pivot) ;
            while(A[--High] > Pivot) ;

            // 上面两个while结束，代表Low指向了一个比P大的点，High指向了一下小的点
            // 如果还没遍历完（Low和High还未交叉）
            if(Low < High) Swap(&A[Low] , &A[High]) ;
            else break;
        }

        Swap(&A[Low] , &A[Right-1]) ; // 将基准换到正确的位置

        // 递归调用左右两块
        Qsort(A,Left , Low-1) ;
        Qsort(A,Low+1 , Right) ;

}

// 一个统一的调用函数
void QuickSort(ElementType A[] , int N){
    Qsort(A,0,N-1);
}
```

# 归并排序  
归并是一种经典的分治，将数组分为两块不断计算顺序，然后合并  
C语言实现中，我们将Merge的部分和Sort的部分分开，然后用一个接口调用  
其如下：    
```c
// 归并排序 

// L左边起始位置  ， R 右边起始位置 ， End终点位置（右侧    
void Merge(ElementType A[] , ElementType TmpA[] , int L ,int R ,int End){
    // 将有序的A[L] -> A[R-1]和 A[R]->A[End] 归并为一个有序序列 
    int leftEnd , NumElements , Tmp ; 
    int i ; 

    leftEnd = R-1 ; //左侧终点  
    Tmp = L ;  // 起始位置  

    NumElements = End-L+1 ; //计算数组总数

    // 归并
    while(L <= leftEnd && R <= End){
        if(A[L] <= A[R])    TmpA[Tmp++] = A[L++] ; 
        else                TmpA[Tmp++] = A[R++] ; 
    }

    // 对于剩下的进行处理   
    while(L <= leftEnd) TmpA[Tmp++] = A[L++] ; 
    while(R <= End)     TmpA[Tmp++] = A[R++] ; 

    for(i=0 ; i<NumElements ; i++,End--){
        // 复制回原数组 
        A[End] = TmpA[End] ;
    }
}

// 归并函数的核心递归排序
void M_Sort(ElementType A [] , ElementType TmpA[] , int L ,int End){
    int Center ; 

    if(L < End){
        Center = (L+End) / 2 ;
        M_Sort(A,TmpA,L,Center); // 递归解决左边
        M_Sort(A,TmpA,Center+1,End);// 递归解决右边

        // 进行合并操作
        Merge(A,TmpA,L,Center,End); //这里是Merge
    }
}

// 统一调用函数 
void MergeSort(ElementType A[] , int N){
    ElementType *TmpA ; 
    // 生成临时数组 
    TmpA = (ElementType *)malloc(N * sizeof(ElementType)); 

    if(TmpA != NULL ){
        M_Sort(A,TmpA,0,N-1);
        // 调用结束记得释放空间
        free(TmpA );
    }else{
        printf("空间不足，失败 \n") ; 
    }
}
```

# 基数排序  

## 桶排序   
当数据量小时，直接用一个记录“数据”次数的组，比如G[1]就代表数字"1"的出现次数 
然后遍历原数组，计数，最后将得到的G数组依次输出即可     
伪代码：    
```c
void BucketSort(ElementType A [] , int N){
    count[] 初始化

    while(依次读入数值num){
        将其加入count[num]链表
    }

    for(遍历count[]链表){
        if(count[i]){
            输出
        }
    }
}
```

## 基数排序 
