# 插入排序  
最好情况 ： O(N)  , 均是顺位    
最好情况 ： O(N^2)  , 均是逆序  

插入排序是比较稳定的一种排序方式    

## 简单插入排序
简单插入排序的核心思想是：将待排序的一组序列分为已排好序的和未排好序的两部分    


```c
# include <stdio.h>
# include <stdlib.h>

#define FALSE 0;
#define TRUE 1   ;
#define ERROR -1 ;

typedef int ElementType ;
typedef int bool ;

// 插入排序 
void InserionSort(ElementType A[] , int N){
    // 认为结果数组是从小到大排序的

    int P , i ;
    ElementType tmp ; 

    // 逐步遍历未排序序列的元素
    for(P=1;P<N;P++){
        tmp = A[P] ; // 取出未排序数组的第一个元素  

        for(i=P ; i>0 && A[i-1]>tmp ; i--)
        {
            // 从尾部开始，直到找到一个"tmp比它大"的位置插入
            // 因此比tmp大的部分都需要后移
            A[i] = A[i-1] ; 
        }

        A[i] = tmp ; // 放入合适位置    
    }
}
```

## 希尔排序
希尔排序的核心则在于加入了**间隔**，即改成对每D个元素进行排序，然后递减D    
简易的希尔排序D_k = (D_k+1) / 2 。有的时候它并不理想    

这里的代码实现使用了SedgeWick增量序列来进行希尔排序 

```c
void ShellSort(ElementType A[] , int N){
    int Si , D, P , i ; 

    ElementType Tmp ; 

    // 定义SedgeWick增量序列（这里只使用一部分）    
    int SedgeWick[]={929,505,209,109,41,19,5,1,0};
    for(Si = 0 ; SedgeWick[Si] >= N ; Si++); //设定初始增量的长度   

    for(D=SedgeWick[Si] ; D>0 ; D= SedgeWick[++Si])
        for(P = D ; P< N ;P++){
            Tmp = A[P] ; 
            for(i = P ; i>=D && A[i-D] > Tmp ; i-=D)
                A[i] = A[i-D] ; 

            A[i] = Tmp ; 
        }
}
```

# 选择排序  
## 简单选择排序 
简单选择排序就是最基本的做法，找到最小值，然后交换，一直持续下去    
**找到最小值**的部分直接使用遍历查找    
其实现如下: 
```C

```