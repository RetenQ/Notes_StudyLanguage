# 队列  
队列是具有一定操作约束的线性表  
具体一点，就是遵循FIFO，只能在一端插入，而在另外一端删除    

队列也有两种存储方式，分别是顺序存储和链式存储  

## 顺序存储 
由一维数组负责元素记录，配合一个记录队列头元素位置的front和一个记录尾元素位置的rear组成     

同时，如果我们采用普通的顺序存储，会浪费很多空间，这是我们不希望看到的，所以可以采用一个**循环队列存储**，到头后折返到首位  
但是，如果不做处理的话，front和rear下标关系如下：   
1.front = rear 为空，比如初始化的时候二战都为0  
2.其他情况，正常运行    
3.队列满时，这时候rear从front"后面的位置"到达了front所在的位置。也就是说队列满时仍然是front = rear ; 
所以无法正常表示所有情况。本质是因为只有n个插值情况，但是有n+1个情况    

因此有两种解决方案：    
1.使用一个额外参数。比如使用size实时记录大小，或者使用flag标记上一个操作是入队还是出队以判断情况    
2.只使用n-1个空间，即在```(rear+1)%Maxsize == front```的时候就判断队列满    

根据第二种方案，实现如下：  
```c
# include <stdio.h>
# include <stdlib.h>

#define FALSE 0;
#define TRUE 1   ;
#define ERROR -1 ;

typedef int ElementType ;
typedef int bool ;

typedef int Position ;
typedef struct QNode * PtrToQNode ;
struct QNode
{
    ElementType * Data ; //存储元素的数组
    Position Front , Rear ; //头尾指针
    int MaxSize ; //队列最大容量
};
typedef PtrToQNode Queue ;

// 创建队列与基本操作
Queue CreateQueue(int MaxSize){
    Queue Q = (Queue)malloc(sizeof(struct QNode)) ;
    Q->Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)) ;
    Q->Front = Q->Rear = 0 ; // 两个位置初始化都为0
    Q->MaxSize = MaxSize ;
}

bool IsFull(Queue Q){
    return ((Q->Rear + 1) % (Q->MaxSize) == Q->Front) ;
    // 核心是尾指针+1后会不会和头指针重叠，利用MaxSize计算余数情况
}

bool isEmpty(Queue Q){
    return (Q->Front == Q->Rear) ;
}

// 操作和删除
bool AddQ(Queue Q , ElementType X){
    printf("尝试加入 %d \n" , X);
    if(IsFull(Q)){
        printf("队伍满, %d 加入失败 \n " ,X ) ;
        return FALSE ;
    }else{
        Q->Rear = (Q->Rear + 1) % Q->MaxSize ; // 移动尾部
        Q->Data[Q->Rear] = X ; //增加元素
    }
}

ElementType DeleteQ(Queue Q){
    if(isEmpty(Q)){
        printf("队列空\n") ;
        return ERROR ;
    }else{
        Q->Front = (Q->Front + 1) % Q->MaxSize ; //移动头
        return Q->Data[Q->Front] ; //得到元素
    }
}

// 测试函数
int main(){
    printf("\n生成Size为5的表格（在这个实现中实际只可以存4个）\n");
    Queue Q = CreateQueue(5) ; //最大为5
    printf("\n加入五个元素\n");
    int k = 0 ;
    for(k = 1 ; k <= 5 ;k++){
        AddQ(Q,k) ;
    }
    printf("POP两个元素\n");
    int tmp =0 ;
    tmp = DeleteQ(Q) ;
    printf("弹出： %d \n" , tmp) ;
    tmp = DeleteQ(Q) ;
    printf("弹出： %d \n" , tmp) ;
    printf("\n加入两个元素\n");
    AddQ(Q,77) ;AddQ(Q,88) ;
    printf("\n尝试再加入一个元素\n");
    AddQ(Q,99);



    return 0 ;
}

```

## 链式存储 
队列的链式结构同样可以用一个单链表来实现    
插入和删除操作分别在链表的两天进行  
**将链表头做Front,尾做rear**,因为在单向链表中，只有头的部分知道“删除之后的下一个元素是什么”，因此只能按这个模式分析 

### 不带头结点的一个实例
下面是不带头结点的链式结构的一个示例：  
```c
# include <stdio.h>
# include <stdlib.h>

#define FALSE 0;
#define TRUE 1   ;
#define ERROR -1 ;

typedef int ElementType ;
typedef int bool ;

typedef struct Node * PtrToNode ;
struct Node
{
    ElementType Data ;
    PtrToNode Next ;
};

typedef PtrToNode Position ;

typedef struct QNode * PtrToQNode ;

struct QNode
{
    Position Front , Rear ; //分别指向头和尾的指针
    int Size ; //维护一个容量
};

typedef PtrToQNode Queue;

// 创建队列与基本操作
Queue CreateQueue(){
    Queue Q ;
    Q = (PtrToQNode)malloc(sizeof(struct QNode));
    Q->Front = NULL ;
    Q->Rear = NULL;
    Q->Size = 0 ;

    return Q ;
}

bool isEmpty(Queue Q){
    return (Q->Front == NULL) ; // 头结点的next是空
}

int getSize(Queue Q){
    return Q->Size ;
}

// 操作和删除
bool AddQ(Queue Q , ElementType X){
    Position tmp ;
    tmp = (PtrToNode)malloc(sizeof(struct Node)) ;
    tmp->Data = X ;
    tmp->Next = NULL ;

    if(Q->Front == NULL){
        // 插入的是第一个结点
        // ! 注意，这一步无论"带不带头结点"都需要判断是不是第一个插入进去的指针，否则会造成结点直接连接失败（Front会一直指向NULL）
        Q->Front = tmp ;
        Q->Rear = tmp ;
    }else{
        // 非第一个结点
        Q->Rear->Next = tmp ; //更新tmp的插入位置
        Q->Rear = tmp ; // 尾指针指向tmp
    }

    Q->Size++ ;
    printf("成功加入 %d , 当前size为%d \n" , Q->Rear->Data , Q->Size);

}

ElementType DeleteQ(Queue Q){
    Position FrontCell ;//一个存储当前头结点的指针
    ElementType FrontEle ; // 头部数据

    if(isEmpty(Q)){
        printf("队列空，删除失败 \n") ;
        return ERROR ;
    }else{
        // 获取所要的元素
        FrontCell = Q->Front ;
        FrontEle = FrontCell->Data ;
        // 处理队列
        if(Q->Front == Q->Rear){
            //如果队列只有一个元素
            Q->Front = Q->Rear = NULL; // 直接置空队列就是删除
        }else{
            Q->Front = FrontCell->Next ; // Front直接指向下一位就完成了操作
        }

        // 释放空间
        free(FrontCell) ;
        Q->Size--;
        printf("完成出队，当前size为 %d \n" , Q->Size) ;

        return FrontEle ;
    }
}

// 测试函数
int main(){
    printf("\n生成表格\n");
    Queue Q = CreateQueue() ; //最大为5
    printf("\n加入五个元素\n");
    int k = 0 ;
    for(k = 1 ; k <= 5 ;k++){
        AddQ(Q,k) ;
    }
    printf("POP两个元素\n");
    int tmp =0 ;
    tmp = DeleteQ(Q) ;
    printf("出队： %d \n" , tmp) ;
    tmp = DeleteQ(Q) ;
    printf("出队： %d \n" , tmp) ;
    printf("\n加入两个元素\n");
    AddQ(Q,77) ;AddQ(Q,88) ;
    printf("\n尝试再加入一个元素\n");
    AddQ(Q,99);

    printf("按顺序进行出队直到队列空\n");
    while(Q->Size > 0){
    tmp = DeleteQ(Q) ;
        printf("出队： %d \n" , tmp) ;
    }
    return 0 ;
}

```

### 带头结点的一个实例  
个人认为本质上并没有区别，只是无论如何都不会造成最初的链表头指针改变    

```c
# include <stdio.h>
# include <stdlib.h>

#define FALSE 0;
#define TRUE 1   ;
#define ERROR -1 ;

typedef int ElementType ;
typedef int bool ;

typedef struct Node * PtrToNode ;
struct Node
{
    ElementType Data ;
    PtrToNode Next ;
};

typedef PtrToNode Position ;

typedef struct QNode * PtrToQNode ;

struct QNode
{
    Position Front , Rear ; //分别指向头和尾的指针
    int Size ; //维护一个最大值
};

typedef PtrToQNode Queue;

// 创建队列与基本操作
Queue CreateQueue(){
    Queue Q ;
    Q = (PtrToQNode)malloc(sizeof(PtrToQNode));

    // 创建头结点
    Position _head ;
    _head = (Position)malloc(sizeof(struct Node));
    _head->Data = 0 ;
    _head->Next = NULL ;

    // 将头尾的指针都指向头结点
    Q->Front = Q->Rear = _head ; //先把头尾都定义为空的头结点

    Q->Size = 0 ;

    return Q ;
}

bool isEmpty(Queue Q){
    return (Q->Front == Q->Rear) ;
    // 若头尾指向了同一处，则是空
}

// 操作和删除
bool AddQ(Queue Q , ElementType X){
    Position tmp ;
    tmp = (PtrToNode)malloc(sizeof(struct Node)) ;
    tmp->Data = X ;
    tmp->Next = NULL ;

    if(Q->Front == NULL){
        // 插入的是第一个结点
        // ! 注意，这一步无论"带不带头结点"都需要判断是不是第一个插入进去的指针，否则会造成结点直接连接失败（Front会一直指向NULL）
        Q->Front = tmp ;
        Q->Rear = tmp ;
    }else{
        // 非第一个结点
        Q->Rear->Next = tmp ; //更新tmp的插入位置
        Q->Rear = tmp ; // 尾指针指向tmp
    }
    Q->Size++;

    printf("成功加入 %d , 当前size为%d \n" , Q->Rear->Data , Q->Size);


    return TRUE ;
}

ElementType DeleteQ(Queue Q){
    // 首先判断空
    if(isEmpty(Q)) {
        printf("空队列，出队失败 \n") ;
        return ERROR ;
    }else{

        // 先获取对应元素

        Position frontP = Q->Front->Next ; //要得到Front的Next结点才对，相当于顺序表里面先进行++
        ElementType ElementP = frontP ->Data ;

        if( frontP == Q->Rear){
            // 最后一个元素出队，直接将队列归0
            Q->Rear = Q->Front ;
        }else{
            Q->Front->Next = frontP->Next ; //头指针指向的Next重定义为原本P的下一个元素，达到删除P的目的
        }

        // 执行操作
        // 进行释放操作与size修改
        Q->Size-- ;

        free(frontP) ;

        printf("完成出队 %d，当前size为 %d \n" ,ElementP, Q->Size) ;
        return ElementP ;
    }
}

// 测试函数
int main(){
    printf("\n生成表格\n");
    Queue Q = CreateQueue() ; //最大为5
    printf("\n加入五个元素\n");
    int k = 0 ;
    for(k = 1 ; k <= 5 ;k++){
        AddQ(Q,k) ;
    }
    printf("出队两个元素\n");
    int tmp =0 ;
    tmp = DeleteQ(Q) ;
    printf("出队： %d \n" , tmp) ;
    tmp = DeleteQ(Q) ;
    printf("出队： %d \n" , tmp) ;
    printf("\n加入两个元素\n");
    AddQ(Q,77) ;AddQ(Q,88) ;
    printf("\n尝试再加入一个元素\n");
    AddQ(Q,99);

    printf("按顺序进行出队直到队列空\n");
    while(Q->Size > 0){
        tmp = DeleteQ(Q) ;
        printf("出队： %d \n" , tmp) ;
    }
    return 0 ;
}

```