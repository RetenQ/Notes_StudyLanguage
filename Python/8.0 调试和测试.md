# 8.0调试和测试 

## try except finally   
当我们认为某些代码可能会出错时，就可以用```try```来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即```except```语句块     
执行完```except```后，如果有```finally```语句块，则执行```finally```语句块，至此，执行完毕      

```py
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')
```

同时，根据错误的不同类型，我们也可以使用多个```except```来捕获不同的错误    
```py
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
```

此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句
```py
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
``` 

### BaseException   
Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还**把其子类也“一网打尽”**,也就是说，如果父类的Exception在子类前面，那么子类不会捕获到错误  
```py
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
```

第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。  

常见的错误类型和继承关系可见: https://docs.python.org/3/library/exceptions.html#exception-hierarchy 

### 调用栈、记录错误  
如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出    

如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。    
此时就可以利用python自带的```logging```模块进行记录 
```py
# err_logging.py

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')
``` 
此时在发生错误的时候logging通过代码```logging.exception(e)```来进行错误的记录，但同时不影响程序的继续使用。相当于同时完成了记录+调试    
```py
$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File "err_logging.py", line 13, in main
    bar('0')
  File "err_logging.py", line 9, in bar
    return foo(s) * 2
  File "err_logging.py", line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END
``` 

> 通过配置，logging还可以把错误记录到日志文件里，方便事后排查   

### 错误抛出    
> 因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误    

对于抛出错误，我们可以根据自己的需要自定义一个错误的class，然后通过```raise```语句来抛出错误实例    

```py
# err_raise.py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n==0:
        raise FooError('invalid value: %s' % s)
    return 10 / n

foo('0')
```

只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型,或者说，尽量使用Python内置的错误类型   

```raise```语句如果不带参数，就会把当前错误原样抛出。此外，在```except```中```raise```一个Error，还可以**把一种类型的错误转化成另一种类型** 
```py
try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')    
``` 

## 断言 
可以使用断言```assert```来辅助调试：    
```py
def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n

def main():
    foo('0')
```
```assert```的意思是，表达式```n != 0```应该是**True**，否则，根据程序运行的逻辑，后面的代码肯定会出错。    

如果断言失败，```assert```语句本身就会抛出```AssertionError```  

> 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数(大写字母O)来关闭assert    

## logging  
和assert比，logging不会抛出错误，而且可以输出到文件 
```py
import logging

s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
``` 

此时的logging是比较简单的模式，我们可以通过修改```logging```的配置来输出更多的信息  
```py
import logging
logging.basicConfig(level=logging.INFO)
```

logging的好处，它允许你指定记录信息的级别，有```debug```，```info```，```warning```，```error```等几个级别  
样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息  

logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件    

## pdb调试器    
第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态    

```py
# err.py
s = '0'
n = int(s)
print(10 / n)
```

在执行的时候启用调试器：
```py
$ python -m pdb err.py
> /Users/michael/Github/learn-python3/samples/debug/err.py(2)<module>() 
-> s = '0'  
```
以参数```-m pdb```启动后，pdb定位到下一步要执行的代码```-> s = '0'```。输入命令```l```来查看代码    

输入命令```n```可以单步执行代码 

任何时候都可以输入命令```p 变量名```来查看变量  

### pdb.set_trace() 
通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了。我们只需要import pdb，然后，在可能出错的地方放一个```pdb.set_trace()```，就可以***设置一个断点** 

运行代码，程序会自动在```pdb.set_trace()```暂停并进入pdb调试环境，可以用命令```p```查看变量，或者用命令```c```继续运行  

## 单元测试和文档测试   
https://www.liaoxuefeng.com/wiki/1016959663602400/1017604210683936  

https://www.liaoxuefeng.com/wiki/1016959663602400/1017605739507840