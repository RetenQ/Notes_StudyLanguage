### 循环    
Python中有两种循环  

#### for in
首先是"for-in"循环，它能够依次把list或tuple中的每个元素迭代出来 
```Python
names = ['A','B','C']
for name in names :
    print(name)
```
这样的代码会打印names的每一个元素，结果是:
A   
B   
C   

所谓 for x in M ,就是把M中的一个元素，都代入x,然后执行缩进块里面的语句  

比如我们要写一个1-10的整数和:
```Python
sum = 0 
for x in [1,2,3,4,5,6,7,8,9,10]:
    sum = sum + x
print(sum)
```

顺带一提，可以利用range()函数得到一个整数序列，range(x)是从0开始，小于x的所有整数   

```Python
sum = 0  
for x in range(101):
    sum = sum + x
print(sum)
```

#### while
经典之while循环，只要条件满足，就不断循环   
比如我们计算100之内的奇数和:
```Python
sum = 0 
n = 99
while n>0:
    sum = sum +n 
    n = n - 2
print(sum)
```

#### break 和 continue
使用break提前退出循环   
continue则是跳过本次循环的剩余语句，直接进入下一次循环  

>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用    

>要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句   

>有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程   

### dict 和 set 
#### dict
dict的支持，dict全称dictionary，在其他语言中也称为map，使用**键-值（key-value）存储**，具有极快的查找速度   

比如我们想要利用一个dict，做出一个"名字-成绩"的对照表，再根据名字查找成绩   
>这种情况下，无论表多大，查找速度都不会变   

```Python
d = {'Michael':95,'Bob':75,'Tracy':85}
d['Miceael']
```
会得到 95 的结果    

>给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快   

说到所谓**key**，我们将数据放入dict的时候，除了初始时指定外，还可以通过key放入  
```Python
d['A'] = 15 
d['A']
```
得到的结果就是15    

##### 寻找key
当然，当我们要找的key不存在时，就会得到一个报错。我们有两种办法避免"寻找不存在的key"

首先是用**in**来判断，它会返回一个布尔值来表示某个key是否存在   

``` 'BESR' in name```
结果是False，因为在name里面不包含'BESR' 

第二种就是dict所带的get()方法，如果key不存在，就会返回none或者自己指定的一个value:
```name.get('Mary')``` 若不存在则返回none   
```name.get('Mary',-1)``` 若不存在则返回-1

>注意：返回None的时候Python的交互环境不显示结果 

##### 删除key
使用pop(key)来删除一个key，此时key和对应的value都会被删除   
```Python
>>>d.pop('Bob')
75
>>>d
{'Michael':95,'Tracy':85}
```

#### dict小结
1.dict内部存放的顺序和key放入的顺序**无关**  
2.和list比较,dict查找和插入的速度极快，不会随着key的增加而变慢,但需要占用大量的内存，内存浪费多
>dict:以空间换取时间    
3.**dict的key必须是不可变对象** 
>因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）
>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key

### Set
set和dict类似，也是一组key的集合，但**不存储value** 
由于key不能重复，所以，在set中，没有重复的key   

要创建一个set，需要提供一个list作为输入集合

```Python
>>> s = set([1,2,3])
>>> s
{1,2,3}
```

>传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的

而重复的元素在set中会被自动过滤
```Python
>>> s = set([1,1,2,2,2,3])
>>> s
{1,2,3}
``` 

### add添加元素
使用add(key)来把元素添加至set中 
重复添加的元素会被自动过滤
```Python
>>>s.add(4)
>>>s
{1,2,3,4}
>>>s.add(4)
>>>s
{1,2,3,4}
```

>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作 

```Python
>>>s1 = set([1,2,3])
>>>s2 = set([2,3,4])
>>>s1 & s2
{2,3}
>>>s1 | s2
{1,2,3,4}
```

>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”   

>另外，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的