# 7.1 Python中的面向对象高级特性    
## 使用__slots__    
Python允许在定义class的时候，定义一个特殊的```__slots__```变量，来限制该class实例能添加的属性   
```py
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```     
此时，我们就只能为Student类来帮'name'和'age'两个属性了  

注意，```__slots__```定义的属性仅对当前类实例起作用，对继承的子类是不起作用的   

## 使用@property    
Python内置的@property装饰器就是负责**把一个方法变成属性**调用的     

把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作   

要特别注意：属性的方法名不要和实例变量重名。    

```py
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value


>>> s = Student()
>>> s.score = 60 # OK，实际转化为s.set_score(60)
>>> s.score # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
``` 

## 多重继承 
类似于Java中的接口的概念,在括号里面写入多个类       
比如Dog同时属于Mammal和Runnable，则：   
```py
class Dog(Mammal, Runnable):
    pass
``` 

## 定制类   
### __str__方法     
定制str方法可以设置打印某个类时展示的内容，类似于java的toString()   
```py
>>> class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return 'Student object (name: %s)' % self.name
...
>>> print(Student('Michael'))
Student object (name: Michael)  
```

> 直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的    

### __iter__方法    
如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个```__iter__()```方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的```__next__()```方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。   

以斐波那契数列为例: 
```py
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值

```

### __getitem__方法 
要表现得像list那样按照下标取出元素，需要实现__getitem__()方法   
```py
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
```    

### __getattr__方法 
调用不存在的属性时，Python解释器会试图调用```__getattr__(self, '准备调用的名字')```来尝试获得属性，这样，我们就有机会返回score的值  

> 注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。  

### __call__方法    
一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的 

任何类，只需要定义一个__call__()方法，就可以直接**对实例进行调用**  

```py
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)

>>> s = Student('Michael')
>>> s() # self参数不要传入
My name is Michael.
```

## 枚举类和元类 
### 枚举类  
Python提供了Enum类来实现枚举的功能，利用```Enum```来创建枚举类  
注意，使用Enum需要先import  
既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量   
```py
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
``` 

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类如下: 
```py
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6

``` 
unique装饰器可以帮助我们检查保证没有重复值。    

> 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量 

### 元类    
动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的    

#### type() 
type()函数可以查看一个类型或变量的类型  
type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)...的定义：   
```py
>>> def fn(self, name='world'): # 先定义函数
...     print('Hello, %s.' % name)
...
>>> Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
>>> h = Hello()
>>> h.hello()
Hello, world.
>>> print(type(Hello))
<class 'type'>
>>> print(type(h))
<class '__main__.Hello'>
``` 
**要创建一个class对象，type()函数依次传入3个参数：**    
1.class的名称；
2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法（即在括号里面写元素+逗号）；    
3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。  

> 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。  

#### metaclass  
除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass   ，直译为元类，简单的解释就是：  
先定义metaclass，就可以创建类，最后创建实例     

> metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到    

https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072  
