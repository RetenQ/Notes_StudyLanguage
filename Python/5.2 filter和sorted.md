# filter / sorted

### filter
filter()接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False**决定保留还是丢弃该元素**  

也就是说，filter的主要作用还是在于**保留和丢弃元素**，起到**筛选的作用**    

比如我想要再一个list中，删掉偶数、只留下奇数，那么:
```Python
def is_idd(n):
    return  n % 2 ==1

list(filter(is_odd,[1,2,4,5,6,9,10,15]))

# 结果是 [1,5,9,15]
```

想要删掉一个序列中的空字符串，可以写作:
```Python
def not_empty(s):
    return s and s.strip()

list(filter(not_empty,['A','','B',None,'C',' ']))

# 结果是：['A','B','C'] 
```

> 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list    

### 实例:求素数
计算素数的一个方法是埃氏筛法:
首先，列出从2开始的所有自然数，构造一个序列：
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ..
取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

不断筛下去，就可以得到所有的素数    

先建立一个可以生成从3开始的，无限的奇数序列的生成器:
```Python
def _odd_iter():
    n =1 
    while True:
        n = n+2
        yield n
```

之后我们定义一个筛选函数，其返回值是布尔值，使得我们可以通过filter筛选  
```Python
def _not_divisible(n):
    return lambda x:x % n > 0
```

定义一个生成器不断返回下一个素数
```Python
def primes():
    yield 2
    it = _odd_iter()  #初始化，得到刚才的生成器
    while True:
        n = next(it) #返回序列的第一个数
        yield n 
        it = filter(_not_divisible(n),it) # 构造新序列
```

>这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列

结合使用即可，另外我们的primes()也是一个无限序列，因此我们要给我们的循环设置一个退出循环的条件  

```Python
# 以打印1000以内的素数为例
for n in primes():
    if n <1000:
        print(n)
    else:
        break
```

> filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素    

### sorted
排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来  

Python内置的sorted()函数就可以实现排序的功能:
```Python
>>> sorted([36,5,-12,9,-21])
[-21, -12, 5, 9, 36]
```

此外，sorted()函数也是一个**高阶函数**，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序 

```Python
>>> sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
```

**key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行后续操作** 
(这里的作用就是abs,对list元素绝对值化。后续操作就是排序)    

### 字符串排序
```Python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'])
['Credit', 'Zoo', 'about', 'bob']
```

默认情况下，对字符串排序，是按照ASCII的大小比较的
此时，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面   
现在，我们提出排序应该忽略大小写，按照字母序排序

要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先**把字符串都变成大写（或者都变成小写）**，再比较       

```Python
>>> sorted(['bob','about','Zoo','Credit'], key = str.lower)
['about', 'bob', 'Credit', 'Zoo']   
```

如果还有来一个附加的反向排序,即使用reverse

```Python
>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
```

> sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数    

