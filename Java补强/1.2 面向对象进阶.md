# 面向对象进阶

### 覆写
子类如果定义了一个与父类**方法签名完全相同**的方法，被称为覆写（Override）  

```Java
class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

覆写Override和重载Overload不同    
如果方法签名不同，就是Overload，Overload方法是一个新方法；
如果方法签名相同，并且返回值也相同，就是Override

> 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错

> 方法签名就由方法名+形参列表构成。方法名和形参数据类型列表可以唯一的确定一个方法，与方法的返回值一点关系都没有，这是判断重载重要依据   

Java的实例方法调用是基于**运行时**的实际类型的**动态调用**，而非变量的声明类型，比如下方代码:
```Java
public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        p.run(); // 应该打印Person.run还是Student.run?
    }
}

class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```
最终打印的是Student.run 
这个非常重要的特性在面向对象编程中称之为多态

### 多态 Polymorphic
多态是指，针对某个类型的方法调用，其真正执行的方法取决于**运行时期**实际类型的方法  

多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码  

> 可认为，“多态”的作用就在用：处理父类，对于子类的多个状态能够一并处理。可以认为利用了“向上转型+覆写”的特性，以特殊的子类+特殊的方法覆写得到对应的特殊结果，而处理这一点的函数只需要与它的父类打交道就行了。

找一个人并打印职业->方法一个Person类->此时传入一个Student类->因为动态调用的特性，调用Student类的东西->“打印职业”的代码被覆写->打印Student

### 其它    

#### 覆写Object的方法
toString()：把instance输出为String；
equals()：判断两个instance是否逻辑相等；
hashCode()：计算一个instance的哈希值

#### 调用super
在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用   

#### final
如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final   
**用final修饰的方法不能被Override**     

更广泛一点，如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final     
**用final修饰的类不能被继承**   

对于一个类的实例字段，同样可以用final修饰   
**用final修饰的字段在初始化后不能被修改**   

也可以在构造方法中初始化final字段   
**这种方法更为常用，因为可以保证实例一旦创建，其final字段就不可修改**   

### 抽象类