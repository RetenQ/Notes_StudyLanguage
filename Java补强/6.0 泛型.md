# 泛型  
泛型是一种“代码模板”，可以用一套代码套用各种类型    

泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查    

注意泛型的继承关系：可以把ArrayList<Integer>向上转型为List<Integer>（T不能变！），但不能把ArrayList<Integer>向上转型为ArrayList<Number>（T不能变成父类）    

## 使用泛型 
使用泛型时，把泛型参数<T>替换为需要的class类型  
不指定泛型参数类型时，编译器会给出警告，且只能将<T>视为Object类型； 

### 基本
使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object。在这个时候，实际上只能把<T>当作```object```来使用，并没有发挥出泛型的优势  

只有在定义了泛型的类型之后，才能使用相对的操作：    
例如，我们定义其为String:
```java
List<Sting> list = new ArrayList<String>();
list.add("Hello") ; 
list.add("World") ; 

String first = list.get(0) ; 
String second = list.get(1) ; 
```

同理定义Number类型：
```java
List<Number> list = new ArrayList<Number>() ; 
list.add(new Integer(123)) ; 
list.add(new Double(12.34)) ; 
Number first = list.get(0) ; 
Number second = list.get(1) ; 
```

另外，当编译器可以自动推断出泛型类型的时候，就可以省略后面的泛型类型，比如:
```List<Number> list = new ArrayList<Number>();```  
可以直接写为```List<Number> list = new ArrayList<>();```    

### 泛型接口    
可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。    

例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：    
```java
public interface Comparable<T> {
    int compareTo(T o ) ; 
    /**
     * 返回负数: 当前实例比参数o小
     * 返回0: 当前实例与参数o相等
     * 返回正数: 当前实例比参数o大
     */
}
```

## 编写泛型 

### 按步编写:   
首先，按照某种类型来编写:   
```Java
public class Pair {
    private String first;
    private String last;
    public Pair(String first, String last) {
        this.first = first;
        this.last = last;
    }
    public String getFirst() {
        return first;
    }
    public String getLast() {
        return last;
    }
}
``` 

然后，对于特定的类型，改为T：   
```Java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```

### 泛型与静态方法  
泛型类型<T>不能用于静态方法，会导致编译错误，我们无法在静态方法的方法参数和返回类型上使用泛型类型T    

对于静态方法，我们需要单独改写为“泛型方法”，只需要使用了一块类型，如<k>:    
```java
public static <K> Pair<K> create(K first, K last) {
    return new Pair<K>(first, last);
}
``` 
**这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开**    

### 多各泛型类型    
我们可以使用不同符合(比如T和K)来表示不同的泛型类型：    
```java
public class Pair<T, K> {
    private T first;
    private K last;
    public Pair(T first, K last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public K getLast() { ... }
}
``` 

与此同时，在你使用的时候，也同样需要指出两种类型    
```Pair<String, Integer> p = new Pair<>("test", 123);```    

> Java标准库的Map<K, V>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型   

## Java与擦拭法实现泛型 