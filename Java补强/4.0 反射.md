# 反射  
### 介绍
反射，即Reflection,Java中的反射，指的就是程序在**运行期间可以拿到一个对象的所有信息**

通常情况下，我们会通过传入对象实例来调用一个对象的方法或者访问它的字段，如下：  
```java
import com.itranswarp.learnjava.Person;

public class main{
    String getFullNmae(Person p) {
        return p.getFirstName() + " " +p.getLastName();
    }
}
```
不过，如果我们根本没有import Person类，但是还是想要使用这个方法，就需要反射了   

反射：**解决在运行期，对某个实例一无所知的情况下，如何调用其方法**  

## class类  
### 介绍
除了基本类型以外，Java中的其它类型，包括接口，本质上都是class   
我们可以得到结论: class的本质是数据类型(Type)。无继承关系的数据类型无法赋值 

在JVM中，class是JVM在执行的时候动态加载的。JVM在第一次读到某一种class类型的时候，会将其加载进内存中
每加载一种class,JVM就为其创建一个```Class```类型的实例并关联，这里的```Class```类型是一个叫"Class"的类，如下：
```java
public final class Class {
    private Class(){}
}
```

以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来

> Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的

### class类与反射
由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。

这种**通过class实例**来获取**class信息**的方法，就被称为**反射**    

### 如何获取一个class的Class实例    
1.直接通过一个class的静态变量class获取
```Class cls = String.class ; ```

2.如果我们有一个实例变量，可以通过该实例变量提供的```getClasss()```方法来获取   
```java
String s = "Hello" ; 
Class cls = s.getClass();
```

3.如果知道一个class的完整类名，可以通过静态方法```Class.forName()```获取    
```Class cls = Class.forName("java.lang.String");```    

> 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例   

#### 通过instanceof的比较   
或许我们像求证一下两个实例是否相等，此时还可以使用更精一级的```instanceof```    

```java
Integer n = new Integer(123);

boolean b1 = n instanceof Integer; // true，因为n是Integer类型
boolean b2 = n instanceof Number; // true，因为n是Number类型的子类

boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class
boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class
``` 

```insatanceof```不仅匹配指定类型，还可以匹配指定类型的子类。      
而用```==```判断class实例只可以精确地判断数据类型   

> 通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。

### 利用Class实例来创建对应类型的实例   
如果获取到了一个Class实例，我们就可以通过该Class实例来创建对应类型的实例    
```java
Class cls = String.class ; 
String s = (String) cls.newInstance() ; 
```
上面两行代码相当于new String 。 通过Class.newInstance()可以创建类实例，但是它只能调用public的无参数构造方法。   
> 带参数的构造方法，非public 的构造方法都无法通过Class.newInstance()被调用  

### 动态加载    
JVM在执行Java程序的时候，并不是一次性把所有的class全部加载到内存，而是在第一次用的class的时候才进行加载。   
比如现在有：    
```java
public class Main {
    public static void main(String[] args) {
        if(args.length > 0 ) {
            create(args[0]);
        }
    }

    static void create(String name) {
        Person p = new Person(name);
    }
}
```

当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载 

**这就是JVM动态加载class的特性**    

### 小结    
1.JVM为每个加载的class以及interface都创建的对应的Class实例来保存class以及interface的所有信息    
2.获取一个class对应的```Class```实例后，就可以获取该class的所有信息 
3.通过Class实例获取class信息的方法就是**反射**  
4.JVM总是动态加载class,可以在运行期根据条件来控制加载class  

## 访问字段 
Class类提供了以下几个方法来获取字段:    

Field getField(name)：根据字段名获取某个public的field（包括父类）
Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
Field[] getFields()：获取所有public的field（包括父类）
Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）    

### Field对象及其信息获取   
一个Field对象包含了一个字段的所有信息，我们可以用相关的函数返回所需信息 
getName():返回字段的名称    
getType():返回字段类型，也是一个Class实例   
getModifiers():返回字段的修饰符，返回的是一个int，不同的bit表示不同的含义   

以String类的value字段为例，它的定义为:  
```java
public final class String {
    private final byte[] value ;
}
``` 
如果我们利用反射来获取该字段的信息，即可得到:   
```
Filed  f = String.class.getDeclaredField("value");
f.getName() ; //结果是"value"   
f.getType() ; //结果是class [B 表示byte[]类型   

int m = f.getModifiers() ; //结果是一个数值 
//下面利用数值来得到是否是某个修饰符    
Modifier.isFinal(m) ; //True
Modifier.isPublic(m) ; //false
Modifier.isProtected(m);// false
Modifier.isPrivate(m) ; // true 
Modifier.isStatic(m) ; //false
``` 

### 获取字段的值    
用反射拿到Field实例之后，我们还可以设法得到该实例对应的字段的值 
比如，对于一个Person实例，我们可以这么拿值:
```java
public class Main {
    public static void main(String[] args) throws Exception {
        Object p = new Person("Xiao Ming");
        Class c = p.getClass(); //得到实例
        Field f = c.getDeclaredField("name") ; //得到Field

        f.setAccessible(true);//见后文

        Object value = f.get(p);
        System.out.println(value) ; //"Xiao Ming"
    
    }
}


class Person {
    private String name ; 

    public Person(String name){
        this.name = name; 
    }
}
```

其中```f.setAccessible(true);```使得我们可以访问**private**修饰下的字段，其意思是“无论该字段是否是public,一律可以访问”  

如果不加入这一句，则会得到一个IllegalAccessException    

> 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全 

### 设置字段值  
设置字段值是通过```Field.set(object,object)```来实现的，其中第一个object参数是指定的实例，第二个object参数是待修改的值  

可以看看代码示例:   
```java
public class Main {
    public static void main(String[] args) throws Exception {
        Person p = new Person("Xiao Ming") ;
        System.out.println(p.getName()) ; //"Xiao Ming"这是原本的数值   

        //下面开始使用反射
        Class c = p.getClass();
        Field f = c.getDeclaredField("name");
        f.setAccessible(true);//同理得到字段
        //同样的，修改非public字段，需要首先调用setAccessible(true)
        f.set(p,"Mike") ; //进行字段值的新设定  
        System.out.println(p.getName()) ; //结果是Mike
    }
}

class Person {
    private String name ; 
    public Person(String name){
        this.name = name ;
    }

    public String getName(){
        return this.name;
    }
}
```

### 小结    
Java的反射API提供的Field类封装了字段的所有信息：

通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()；

通过Field实例可以获取字段信息：getName()，getType()，getModifiers()；

通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。

通过反射读写字段是一种非常规方法，它会破坏对象的封装。

## 调用方法
Class类提供了以下几个方法来获取Method：

Method getMethod(name, Class...)：获取某个public的Method（包括父类）
Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）
Method[] getMethods()：获取所有public的Method（包括父类）
Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）、

### 代码示例    
```java
public class Main {
    public static void main(String[] args) throws Exception {
        Class stdClass = Student.class ; 

        //1.获取public方法，名字是getScore，参数是String    
        System.out.println(stdClass.getMethod("getScore",String.class)) ; 

        //2.获取基继承的public方法getName,无参  
        System.out.println(stdClass.getMethod("getName"));

        //3.获取private方法getGrade,参数为int   
        System.out.println(stdClass.getDeclaredMethod("getGrade",int.calss));

    }
}

class Student extends Person {
    public int getScore(String type) {
        return 99 ;
    }

    private int getGrade(int yeat) {
        return 1 ; 
    }
}

class Person {
    public String getName(){
        return "Person"  ;
    }
}

``` 

### Method对象  
**一个Method对象包含一个方法的所有信息**    

getName()：返回方法名称，例如："getScore"； 
getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；    
getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； 
getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义  

### 调用方法

当我们获取到了一个Method对象，就可以对它进行调用了  
```java
String s = "Hello world" ; 
String r = s.substring(6) ; //"world"
``` 
如果我们想要用反射来调用```substring```方法，则:
```java
public class Main {
    public static void main(String[] args) throws Exception {
        String s = "Hello world" ; 

        //下面我们来获取String的substring(int)方法 ，其参数为int    
        Method m = String.class.getMethod("substring" , int.class) ;

        //在s对象上调用该方法调用该方法并获取结果   
        String r = (String)m.invoke(s,6);

        //打印
        System.out.println(r);   
    }
}
``` 

> 注意，此时我们得到的方法是String substring(int)这个方法。 

### 调用静态方法    
如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null  

比如:
```java
public class Main {
    public static void main(String[] args) throws Exception {
        Method m = Integer.class.getMethod("parseInt",String.class) ; 

        Integer n = (Integer) m.invoke(null , "12345") ; 

        System.out.println(n) ; 
    }
}
```

### 调用非public方法    
同理，我们也需要使用```Method.setAccessible(true)```    
否则会得到一个```IllegalAccessException```  

---调用非public方法
```java
public class Main {
    public static void main (String[] args) throws Exception {
        Person p = new 
    }
}
```